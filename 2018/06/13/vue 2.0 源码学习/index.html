<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="vue," />










<meta name="description" content="参考: Vue全家桶实现原理简要梳理、Vue 2.0 的 virtual-dom 实现简析、深入Vue2.0底层思想–模板渲染、Vue.js 技术揭秘、从Vue.js源码看异步更新DOM策略及nextTick、Vue 2.0 的 virtual-dom 实现简析  本文 vue@2.0.0 代码结构12345678910111213141516171819202122├── compiler/">
<meta name="keywords" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="vue 2.0 源码学习">
<meta property="og:url" content="http://jhgrrewq.github.io/2018/06/13/vue 2.0 源码学习/index.html">
<meta property="og:site_name" content="jhgrrewq 前端小站">
<meta property="og:description" content="参考: Vue全家桶实现原理简要梳理、Vue 2.0 的 virtual-dom 实现简析、深入Vue2.0底层思想–模板渲染、Vue.js 技术揭秘、从Vue.js源码看异步更新DOM策略及nextTick、Vue 2.0 的 virtual-dom 实现简析  本文 vue@2.0.0 代码结构12345678910111213141516171819202122├── compiler/">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-13/93728031.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-14/25554080.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-15/88660125.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/83987055.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/5191444.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/59141550.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/19380189.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/99938328.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/31595673.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/17332475.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/40488653.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/71819335.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/27358504.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-16/25299407.jpg">
<meta property="og:updated_time" content="2018-06-19T01:35:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue 2.0 源码学习">
<meta name="twitter:description" content="参考: Vue全家桶实现原理简要梳理、Vue 2.0 的 virtual-dom 实现简析、深入Vue2.0底层思想–模板渲染、Vue.js 技术揭秘、从Vue.js源码看异步更新DOM策略及nextTick、Vue 2.0 的 virtual-dom 实现简析  本文 vue@2.0.0 代码结构12345678910111213141516171819202122├── compiler/">
<meta name="twitter:image" content="http://ony85apla.bkt.clouddn.com/18-6-13/93728031.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'O0AP0FGXSX',
      apiKey: 'ab7c2224e88a925feeea82c8902add9d',
      indexName: 'jhgrrewq',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jhgrrewq.github.io/2018/06/13/vue 2.0 源码学习/"/>





  <title>vue 2.0 源码学习 | jhgrrewq 前端小站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jhgrrewq 前端小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">置我于死地者 必将赐我以后生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jhgrrewq.github.io/2018/06/13/vue 2.0 源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jhgrrewq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/8380737?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jhgrrewq 前端小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">vue 2.0 源码学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T09:50:56+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>参考: <a href="https://github.com/tsy77/blog/issues/1" target="_blank" rel="noopener">Vue全家桶实现原理简要梳理</a>、<a href="https://github.com/DDFE/DDFE-blog/issues/18" target="_blank" rel="noopener">Vue 2.0 的 virtual-dom 实现简析</a>、<a href="http://developer.51cto.com/art/201707/545802.htm" target="_blank" rel="noopener">深入Vue2.0底层思想–模板渲染</a>、<a href="https://ustbhuangyi.github.io/vue-analysis" target="_blank" rel="noopener">Vue.js 技术揭秘</a>、<a href="https://juejin.im/post/59c7b25a5188257a125d7a98#heading-4" target="_blank" rel="noopener">从Vue.js源码看异步更新DOM策略及nextTick</a>、<a href="https://github.com/DDFE/DDFE-blog/issues/18" target="_blank" rel="noopener">Vue 2.0 的 virtual-dom 实现简析</a></p>
</blockquote>
<p>本文 <a href="mailto:vue@2.0.0" target="_blank" rel="noopener">vue@2.0.0</a></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── compiler/               <span class="comment">// 解析 template，生成 render 函数和 ast</span></span><br><span class="line">│   ├── codegen/                    <span class="comment">// 根据 ast 生成 render 函数</span></span><br><span class="line">│   ├── directives/                 <span class="comment">// 解析 ast 中指令，生成对应 render 函数</span></span><br><span class="line">│   └── parser/                     <span class="comment">// 正则遍历 template 字符串，通过栈记录元素关系，生成 ast</span></span><br><span class="line">├── core                    <span class="comment">// Vue 实例相关，vue 源码核心</span></span><br><span class="line">│   ├── components/                 <span class="comment">// 通用组件，keep-alive 组件</span></span><br><span class="line">│   ├── global-api/                 <span class="comment">// 注册 Vue 构造函数上的静态方法，如 Vue.install、Vue.set...</span></span><br><span class="line">│   ├── instance/                   <span class="comment">// 注册 Vue.prototype，以及构造函数</span></span><br><span class="line">│   ├── observer/                   <span class="comment">// 数据双向绑定相关，主要有 watcher observer dep</span></span><br><span class="line">│   ├── util/                       <span class="comment">// 工具</span></span><br><span class="line">│   └── vdom/                       <span class="comment">// vnode 相关，包含 createVnode， patchNode 等</span></span><br><span class="line">├── platforms               <span class="comment">// core 基础上扩展</span></span><br><span class="line">│   └── web/                        <span class="comment">// 将 core 中代码包装成 web 平台所需要的方法，如 Vue.prototype.$mount 实际包装了 core 中的 $mount</span></span><br><span class="line">│       ├── compiler/</span><br><span class="line">│       ├── runtime/</span><br><span class="line">│       ├── server/</span><br><span class="line">│       └── util/</span><br><span class="line">├── server/                 <span class="comment">// ssr 相关，执行 Vue 代码，生成 Vue 实例；输出流或字符串，传递给 renderNode，renderNode 通过 vnode 生成各种 HTML 标签</span></span><br><span class="line">├── sfc</span><br><span class="line">│   └── parser.js</span><br><span class="line">└── shared                  <span class="comment">// 上述公共工具</span></span><br><span class="line">    └── util.js</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Vue-构造函数"><a href="#Vue-构造函数" class="headerlink" title="Vue 构造函数"></a>Vue 构造函数</h2><p><code>src/core/instance/index.js</code> 定义了 Vue 构造函数，并且<strong>初始化了一些 Vue.prototype 的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)        <span class="comment">// Vue.prototype._init()...</span></span><br><span class="line">stateMixin(Vue)       <span class="comment">// Vue.prototype.$data/$set/$delete/$watch...</span></span><br><span class="line">eventsMixin(Vue)      <span class="comment">// Vue.prototype.$on/$once/$off/$emit...</span></span><br><span class="line">lifecycleMixin(Vue)   <span class="comment">// Vue.prototype._update()/_mount()/$destroy()...</span></span><br><span class="line">renderMixin(Vue)      <span class="comment">// Vue.prototype._render()...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<h3 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin()"></a>initMixin()</h3><p><code>initMixin()</code> 给 Vue.prototype 挂载了一个 <code>_init()</code> 方法，方便之后 vue 实例初始化调用</p>
<blockquote>
<p>Vue 初始化主要就是<strong>合并配置(<code>mergeOptions()</code>）、初始化生命周期 (<code>initLifecycle()</code>)、初始化事件中心(<code>initEvents()</code>)、初始化 data props cumputed watch methods(<code>initState()</code>)、初始化渲染(<code>initRender()</code>)</strong>等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 合并参数</span></span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initLifecycle(vm) <span class="comment">// 初始化生命周期</span></span><br><span class="line">    initEvents(vm)  <span class="comment">// 初始化事件中心</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>) <span class="comment">// beforeCreate 钩子 数据属性未初始化 vm.$el(vue 实例根 dom 元素) 未初始化</span></span><br><span class="line">    initState(vm) <span class="comment">// 初始化 data props computed watch methods</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>) <span class="comment">// created 钩子 数据属性初始化 vm.$el 未初始化</span></span><br><span class="line">    initRender(vm) <span class="comment">// 初始化渲染</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin()"></a>stateMixin()</h3><p><code>stateMixin()</code> 声明了 <code>Vue.prototype.$data</code>、<code>Vue.prototype.$set</code>、<code>Vue.prototype.$delete</code>、<code>Vue.prototype.$watch</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// flow somehow has problems with directly declared definition object</span></span><br><span class="line">  <span class="comment">// when using Object.defineProperty, so we have to procedurally build up</span></span><br><span class="line">  <span class="comment">// the object here.</span></span><br><span class="line">  <span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">  dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 通过 vm.$data(this.$data) 访问 Vue 实例代理了对其 data 对象属性的访问</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$data'</span>, dataDef)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 vm.$set(this.$set) 设置值，等同于全局 Vue.set</span></span><br><span class="line">  Vue.prototype.$set = set</span><br><span class="line">  <span class="comment">// 通过 vm.$delete(this.$delete) 删除对象的值，如果对象是响应式，确保删除能更新视图，等同于全局 Vue.delete</span></span><br><span class="line">  Vue.prototype.$<span class="keyword">delete</span> = del</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 vm.$watch(cb) / this.$watch(cb) 观察 vue 实例变化的一个表达式或计算属性函数，回调函数得到的参数是新值和旧值</span></span><br><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="eventsMixin"><a href="#eventsMixin" class="headerlink" title="eventsMixin()"></a>eventsMixin()</h3><p><code>eventsMixin()</code> 主要定义了 <code>Vue.prototype.$on</code>、<code>Vue.prototype.$off</code>、<code>Vue.prototype.$once</code>、<code>Vue.prototype.$emit</code>, 原理是利用发布订阅模式，在 <code>Vue._events</code> 中给每一个 event 维护一个订阅队列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/events.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">eventsMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// Vue._events 给每一个 event 维护一个订阅队列，相关回调 push 进入该队列</span></span><br><span class="line">    ;(vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 重新封装一个函数，函数内部先取消该订阅回调，再执行传入的 fn</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 先取消该订阅回调，再执行传入的 fn</span></span><br><span class="line">      vm.$off(event, on)</span><br><span class="line">      fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    on.fn = fn</span><br><span class="line">    vm.$on(event, on)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有参数，清空全部 event 的全部订阅回调（vm._events 设置空对象）</span></span><br><span class="line">    <span class="comment">// 如果没有第二个参数， 对应 event 的订阅队列直接清空（清除所有订阅回调）</span></span><br><span class="line">    <span class="comment">// 如果对应 event 要取消的回调，从 Vue._events 取出该 event 的订阅队列遍历查找后删除</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// all</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// specific event</span></span><br><span class="line">    <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">    <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">      vm._events[event] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// specific handler</span></span><br><span class="line">    <span class="keyword">let</span> cb</span><br><span class="line">    <span class="keyword">let</span> i = cbs.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      cb = cbs[i]</span><br><span class="line">      <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">        cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">    <span class="comment">// 取出 vm._events 对应 event 的订阅回调，并传入参数执行</span></span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">      cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">      <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">        cbs[i].apply(vm, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lifecycleMixin"><a href="#lifecycleMixin" class="headerlink" title="lifecycleMixin()"></a>lifecycleMixin()</h3><p><code>lifecycleMixin()</code> <strong>定义了 Vue 中经常使用的 <code>Vue.prototype.update</code> 方法，每当组件 data 变化或者其他原因需要重新渲染时候，Vue 会调用该方法，对 <code>vnode</code> 进行 diff 和 patch 操作</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    el?: Element | void,</span></span></span><br><span class="line"><span class="function"><span class="params">    hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    vm.$el = el <span class="comment">// vm.$el 已经初始化</span></span><br><span class="line">    <span class="comment">// 即时 vm 实例选项没有 render，$mount 方法调用时候已经 将 template 属性 或 el 属性的 outerHTML 转为 render 函数（在 有 compiler 版本的 vue 库文件下），并将 render 函数 设置为 vm.$options.render 属性值</span></span><br><span class="line">    <span class="comment">// 如果 vue 实例 render 属性不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">      vm.$options.render = emptyVNode</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (vm.$options.template) &#123;</span><br><span class="line">          <span class="comment">// 有 template 属性，说明没能转化为 render 函数，说明使用 运行时版本 vue.js 文件，要么预先转换 template ，要么使用 独立构建版本的 vue.js 文件</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">            <span class="string">'option is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">            <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, <span class="string">'beforeMount'</span>) <span class="comment">// beforeMount 钩子 vm.$el 已经初始化</span></span><br><span class="line">    <span class="comment">// 调动 vm._render, 通过 render 函数返回 vnode</span></span><br><span class="line">    <span class="comment">// 首次渲染 和 每次数据属性更新会执行该 watcher 中的回调，执行 vm._update() 对 vnode 进行 diff 和 patch</span></span><br><span class="line">    vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;, noop)</span><br><span class="line">    hydrating = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// root instance, call mounted on self</span></span><br><span class="line">    <span class="comment">// mounted is called for child components in its inserted hook</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$root === vm) &#123;</span><br><span class="line">      vm._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(vm, <span class="string">'mounted'</span>) <span class="comment">// mounted 钩子 dom 已经挂载</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新节点</span></span><br><span class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果该组件已经挂载过了则表明这个步骤是更新过程，触发 beforeUpdate 钩子</span></span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el <span class="comment">// vm.$el 访问 vue 实例根 dom 元素（挂载元素）</span></span><br><span class="line">    <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">    activeInstance = vm</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode <span class="comment">// vm._vnode 存放的是 旧 vnode</span></span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">      <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">      <span class="comment">// 如果不存在 prevVnode 说明是初次挂载，直接将 vnode 创建一个真实的 dom 节点渲染到 vm.$el (会被替换)</span></span><br><span class="line">      <span class="comment">// vm.$el 为真实 dom</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果存在 prevVnode，进行新旧 vnode 对比 diff，并将需要更新的 dom 操作 patch 形式打到 prevVnode 上，完成真实 dom 更新</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    activeInstance = prevActiveInstance</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="comment">// 更新实例对象的 __vue__</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype._updateFromParent = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    propsData: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    listeners: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentVnode: VNode,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderChildren: ?VNodeChildren</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> hasChildren = !!(vm.$options._renderChildren || renderChildren)</span><br><span class="line">    vm.$options._parentVnode = parentVnode</span><br><span class="line">    vm.$options._renderChildren = renderChildren</span><br><span class="line">    <span class="comment">// update props</span></span><br><span class="line">    <span class="keyword">if</span> (propsData &amp;&amp; vm.$options.props) &#123;</span><br><span class="line">      observerState.shouldConvert = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        observerState.isSettingProps = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> propKeys = vm.$options._propKeys || []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; propKeys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = propKeys[i]</span><br><span class="line">        vm[key] = validateProp(key, vm.$options.props, propsData, vm)</span><br><span class="line">      &#125;</span><br><span class="line">      observerState.shouldConvert = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        observerState.isSettingProps = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update listeners</span></span><br><span class="line">    <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldListeners = vm.$options._parentListeners</span><br><span class="line">      vm.$options._parentListeners = listeners</span><br><span class="line">      vm._updateListeners(listeners, oldListeners)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// resolve slots + force update if has children</span></span><br><span class="line">    <span class="keyword">if</span> (hasChildren) &#123;</span><br><span class="line">      vm.$slots = resolveSlots(renderChildren, vm._renderContext)</span><br><span class="line">      vm.$forceUpdate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 beforeDestroy 钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeDestroy'</span>)</span><br><span class="line">    <span class="comment">// 标识位</span></span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// remove self from parent</span></span><br><span class="line">    <span class="keyword">const</span> parent = vm.$parent</span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</span><br><span class="line">      remove(parent.$children, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// teardown watchers</span></span><br><span class="line">    <span class="comment">// 该组件中的所有 watcher 会从其所在的 Dep 中释放</span></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = vm._watchers.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      vm._watchers[i].teardown()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove reference from data ob</span></span><br><span class="line">    <span class="comment">// frozen object may not have observer.</span></span><br><span class="line">    <span class="keyword">if</span> (vm._data.__ob__) &#123;</span><br><span class="line">      vm._data.__ob__.vmCount--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// call the last hook...</span></span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 调用 destroyed 钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'destroyed'</span>)</span><br><span class="line">    <span class="comment">// turn off all instance listeners.</span></span><br><span class="line">    <span class="comment">// 移除所有事件监听</span></span><br><span class="line">    vm.$off()</span><br><span class="line">    <span class="comment">// remove __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin()"></a>renderMixin()</h3><p><code>renderMixin()</code> 定义了 <code>Vue.prototype._render</code> 等方法，<code>_render</code> 方法调用实例化时传入的 <code>render函数</code>（vue 实例）选项中没有 <code>render 函数</code>，会从 <code>template</code> 属性或 <code>el</code> 属性的 outerHTML 编译成 <code>render 函数</code>)，<strong>生成 vnode</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    el?: Element | void,</span></span></span><br><span class="line"><span class="function"><span class="params">    hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 一般数据、组件更新</span></span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;, noop)</span><br><span class="line">    hydrating = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/render.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></span><br><span class="line"><span class="keyword">import</span> VNode, &#123; emptyVNode, cloneVNode, cloneVNodes &#125; <span class="keyword">from</span> <span class="string">'../vdom/vnode'</span></span><br><span class="line"><span class="keyword">import</span> &#123; normalizeChildren &#125; <span class="keyword">from</span> <span class="string">'../vdom/helpers'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  warn, formatComponentName, bind, isObject, toObject,</span><br><span class="line">  nextTick, resolveAsset, _toString, toNumber, looseEqual, looseIndexOf</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createElement &#125; <span class="keyword">from</span> <span class="string">'../vdom/create-element'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm.$vnode = <span class="literal">null</span> <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span></span><br><span class="line">  vm._renderContext = vm.$options._parentVnode &amp;&amp; vm.$options._parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext)</span><br><span class="line">  <span class="comment">// bind the public createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 除了 vm.$createElement, 之后的 vue 版本还提供了 vm._c 方法，两者支持的参数相同，内部都是调用了 createElement 方法，只是一般 vm.$createElement 一般用于用户手写 render 函数，vm._c 是被 vue 内部被模板编译成的 render 函数使用</span></span><br><span class="line">  vm.$createElement = bind(createElement, vm)</span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">    nextTick(fn, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 从 vm.$options.render 拿到 render 函数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      render,</span><br><span class="line">      staticRenderFns,</span><br><span class="line">      _parentVnode</span><br><span class="line">    &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      <span class="comment">// clone slot nodes on re-renders</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vm.$slots) &#123;</span><br><span class="line">        vm.$slots[key] = cloneVNodes(vm.$slots[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (staticRenderFns &amp;&amp; !vm._staticTrees) &#123;</span><br><span class="line">      vm._staticTrees = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 传入 vm.vm.$createElement 执行 render 函数，返回 vnode</span></span><br><span class="line">      <span class="comment">// 一般在 初始化 vue 实例时候写 render 函数 render：h =&gt; h(...) h 就是 vm.$createElement 方法</span></span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(<span class="string">`Error when rendering <span class="subst">$&#123;formatComponentName(vm)&#125;</span>:`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (config.errorHandler) &#123;</span><br><span class="line">        config.errorHandler.call(<span class="literal">null</span>, e, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (config._isServer) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> e &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// return previous vnode to prevent render error causing blank component</span></span><br><span class="line">      vnode = vm._vnode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</span><br><span class="line">          <span class="string">'should return a single root node.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = emptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    <span class="comment">// _render 方法返回 vnode</span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// shorthands used in render functions</span></span><br><span class="line">  <span class="comment">// _h 其实就是 createElement 函数</span></span><br><span class="line">  <span class="comment">// vue 新版本 _c 也是 createElement 函数</span></span><br><span class="line">  Vue.prototype._h = createElement</span><br><span class="line">  <span class="comment">// toString for mustaches</span></span><br><span class="line">  <span class="comment">// _s 转为字符串</span></span><br><span class="line">  Vue.prototype._s = _toString</span><br><span class="line">  <span class="comment">// number conversion</span></span><br><span class="line">  <span class="comment">// _n 转为数字</span></span><br><span class="line">  Vue.prototype._n = toNumber</span><br><span class="line">  <span class="comment">// empty vnode</span></span><br><span class="line">  <span class="comment">// _e 空 vnode</span></span><br><span class="line">  Vue.prototype._e = emptyVNode</span><br><span class="line">  <span class="comment">// loose equal</span></span><br><span class="line">  Vue.prototype._q = looseEqual</span><br><span class="line">  <span class="comment">// loose indexOf</span></span><br><span class="line">  Vue.prototype._i = looseIndexOf</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render static tree by index</span></span><br><span class="line">  <span class="comment">// _m 通过下标渲染静态节点树 // 传入 index 返回对应的 staticRenderFns 函数并执行</span></span><br><span class="line">  Vue.prototype._m = <span class="function"><span class="keyword">function</span> <span class="title">renderStatic</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    index: number,</span></span></span><br><span class="line"><span class="function"><span class="params">    isInFor?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tree = <span class="keyword">this</span>._staticTrees[index]</span><br><span class="line">    <span class="comment">// if has already-rendered static tree and not inside v-for,</span></span><br><span class="line">    <span class="comment">// we can reuse the same tree by doing a shallow clone.</span></span><br><span class="line">    <span class="keyword">if</span> (tree &amp;&amp; !isInFor) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(tree)</span><br><span class="line">        ? cloneVNodes(tree)</span><br><span class="line">        : cloneVNode(tree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// otherwise, render a fresh tree.</span></span><br><span class="line">    tree = <span class="keyword">this</span>._staticTrees[index] = <span class="keyword">this</span>.$options.staticRenderFns[index].call(<span class="keyword">this</span>._renderProxy)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">        tree[i].isStatic = <span class="literal">true</span></span><br><span class="line">        tree[i].key = <span class="string">`__static__<span class="subst">$&#123;index&#125;</span>_<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tree.isStatic = <span class="literal">true</span></span><br><span class="line">      tree.key = <span class="string">`__static__<span class="subst">$&#123;index&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// render v-for</span></span><br><span class="line">  <span class="comment">// _l 渲染 v-for</span></span><br><span class="line">  Vue.prototype._l = <span class="function"><span class="keyword">function</span> <span class="title">renderList</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    render: (</span>) =&gt; <span class="title">VNode</span></span></span><br><span class="line"><span class="function">  ): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret: ?<span class="built_in">Array</span>&lt;VNode&gt;, i, l, keys, key</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val)) &#123;</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val.length)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.length; i &lt; l; i++) &#123;</span><br><span class="line">        ret[i] = render(val[i], i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; val; i++) &#123;</span><br><span class="line">        ret[i] = render(i + <span class="number">1</span>, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(val)) &#123;</span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(keys.length)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        key = keys[i]</span><br><span class="line">        ret[i] = render(val[key], key, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// renderSlot</span></span><br><span class="line">  <span class="comment">// _t 渲染 slot</span></span><br><span class="line">  Vue.prototype._t = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    fallback: ?Array&lt;VNode&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// apply v-bind object</span></span><br><span class="line">  <span class="comment">// _b 应用 v-bind 对象</span></span><br><span class="line">  Vue.prototype._b = <span class="function"><span class="keyword">function</span> <span class="title">bindProps</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    value: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    asProp?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">VNodeData</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose v-on keyCodes</span></span><br><span class="line">  Vue.prototype._k = <span class="function"><span class="keyword">function</span> <span class="title">getKeyCodes</span> (<span class="params">key: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.keyCodes[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="创建-vue-实例"><a href="#创建-vue-实例" class="headerlink" title="创建 vue 实例"></a>创建 vue 实例</h2><p><img src="http://ony85apla.bkt.clouddn.com/18-6-13/93728031.jpg" alt=""></p>
<p><code>new Vue({})</code> 实际调用了构造函数中的 <code>this._init()</code>, <code>this._init()</code> 就是调用 <code>core/instance/init.js</code> 中定义的 <code>Vue.prototype._init</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    <span class="comment">// 初始化生命周期</span></span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    <span class="comment">// 初始化事件中心</span></span><br><span class="line">    initEvents(vm)</span><br><span class="line">    <span class="comment">// 调用 beforeCreate 钩子函数并触发 beforeCreate 钩子事件</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    <span class="comment">// 初始化 props data methods computed 和 watch</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    <span class="comment">// 调用 created 钩子函数并触发 created 钩子事件</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line">    <span class="comment">// 初始化渲染</span></span><br><span class="line">    initRender(vm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle()"></a>initLifecycle()</h3><p><code>initLifecycle()</code> 主要是将自己 push 到 parent.$children 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="comment">// 初始化生命周期</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line"></span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="comment">// 将 vm 对象存储到 parent 组件中（保证 parent 组件是非抽象组件，如 keep-alive）</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  vm.$root = parent ? parent.$root : vm</span><br><span class="line"></span><br><span class="line">  vm.$children = []</span><br><span class="line">  vm.$refs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm._watcher = <span class="literal">null</span></span><br><span class="line">  vm._inactive = <span class="literal">false</span></span><br><span class="line">  vm._isMounted = <span class="literal">false</span></span><br><span class="line">  vm._isDestroyed = <span class="literal">false</span></span><br><span class="line">  vm._isBeingDestroyed = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents()"></a>initEvents()</h3><p><code>initEvents()</code> 主要初始化 <code>vm._events</code> 事件中心存放事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/events.js</span></span><br><span class="line"><span class="comment">// 初始化事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 vm 上创建 _events 对象用来存放事件以及事件对应的订阅队列</span></span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initRender"><a href="#initRender" class="headerlink" title="initRender()"></a>initRender()</h3><p><code>initRender()</code> 定义了 <code>vm.$createElement</code> 方法，并<strong>执行 <code>vm.$mount</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 render</span></span><br><span class="line"><span class="comment">// src/core/instance/render.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm.$vnode = <span class="literal">null</span> <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span></span><br><span class="line">  vm._renderContext = vm.$options._parentVnode &amp;&amp; vm.$options._parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext)</span><br><span class="line">  <span class="comment">// bind the public createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// 将 createElement 函数绑定到 vm 实例上</span></span><br><span class="line">  vm.$createElement = bind(createElement, vm)</span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p><code>initState()</code> 主要是 <code>initProps, initComputed, initData, initMethods,initWatch</code>，对 props data computed methods watch 等属性进行初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"><span class="comment">// 初始化 props data computed methods watch</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  initProps(vm)</span><br><span class="line">  initData(vm)</span><br><span class="line">  initComputed(vm)</span><br><span class="line">  initMethods(vm)</span><br><span class="line">  initWatch(vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h3><h4 id="initData"><a href="#initData" class="headerlink" title="initData()"></a>initData()</h4><p>以 <code>initData()</code> 为例来理解 Vue 的 响应式原理</p>
<p><code>initData()</code> 对 <code>data</code> 的初始化做了两件事：</p>
<ul>
<li>对定义 <code>data</code> 函数返回对象的遍历，<strong>通过 <code>proxy</code> 方法把每一个值 <code>vm._data.xxx</code> 代理到 <code>vm.xxx</code></strong></li>
<li><strong>调用 <code>observe</code> 方法观测 <code>data</code> 变化，将 <code>data</code> 变成响应式</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 得到 data 数据</span></span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? data.call(vm) <span class="comment">// 组件中 data 属性必须是函数类型</span></span><br><span class="line">    : data || &#123;&#125; <span class="comment">// vue 实例中 data 属性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对对象类型进行严格检查，只有对象是纯 js 对象时返回 true</span></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object.'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="comment">// 遍历 data 对象</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 data 中数据</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="comment">// 保证 data 中的 key 不和 props 中的 key 重复，props 优先，冲突会报 warning</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;keys[i]&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将 data 上面的属性代理到 vm 实例上</span></span><br><span class="line">      proxy(vm, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 对数据进行添加 getter setter，observe 递归对深层对象的遍历，并添加 getter setter</span></span><br><span class="line">  observe(data)</span><br><span class="line">  data.__ob__ &amp;&amp; data.__ob__.vmCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy 方法将 data 上属性代理到 vm 上</span></span><br><span class="line"><span class="comment">// 访问 vm[key], 其实代理访问 vm._data[key]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">vm: Component, key: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是保留字段</span></span><br><span class="line">  <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vm._data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        vm._data[key] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>observe()</code> 中 <code>new Observer()</code>, 最终会对 <code>data</code> 中所有数据调用 <code>defineReactive</code> 变成响应式(包括子对象递归 <code>observe()</code>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    observerState.shouldConvert &amp;&amp;</span><br><span class="line">    !config._isServer &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 核心代码 实例化一个 Observer 对象</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Observer-类"><a href="#Observer-类" class="headerlink" title="Observer 类"></a>Observer 类</h4><p><code>Observer</code> 类用于给对象添加 getter 和 setter，用于依赖收集和派发更新</p>
<ul>
<li>首先实例化 <code>Dep</code> 对象</li>
<li>通过执行 <code>def</code> 函数把自身实例添加到对象 <code>value</code> 的 <code>__obj__</code> 属性上（）</li>
<li>接着对 <code>value</code> 进行判断，对数组会调用 <code>observeArray</code> 方法，否则对纯对象调用 <code>walk</code> 方法；<code>observeArray</code> 遍历数组会再次调用 <code>observe</code> 方法， <code>walk</code> 方法是遍历对象的 key 调用 <code>defineReactive</code> 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/util/lang.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// def(value, '__ob__', this) // 将自身实例添加到数据对象 value 的 __ob__ 属性上</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj: Object, key: string, val: any, enumerable?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 实例化一个发布者 dep 用于收集订阅者 watcher</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 如果属性值是 数组，调用 数组 hack 方法变成响应式</span></span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是数组 new Observer(data) 会调用 walk 函数</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// walk 函数会对 data 中每个属性调用 defineReactive 函数，并将其变为响应式</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h4><p><strong><code>defineReactive</code> 函数主要就是定义一个响应式对象，给对象添加 getter setter</strong></p>
<p><code>defineReactive</code> 函数首先初始化 <code>Dep</code> 对象实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，保证 <code>obj</code> 所有子属性包括嵌套的对象属性都能变成响应式。因此在访问或修改 <code>obj</code> 的任意属性包括子属性，都能触发 getter 和 setter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化一个发布者 dep 用于收集订阅者 watcher</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了 getter 和 setter 钩子函数则将其去除</span></span><br><span class="line">  <span class="comment">// 新定义的 getter setter 会将其执行，保证不会将原来的覆盖</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象的子对象递归进行 observe 并返回子节点的 Observer 对象</span></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果对象原本具有 getter 方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集 将 watcher 添加到 dep 中该数据属性对应的订阅者数组</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">// 子对象进行依赖收集，其实是将同一个 watcher 观察者实例放入一个是当前 dep 中 该数据属性对应的订阅者数组，另一个是子元素 dep 中的 该数据属性对应的订阅者数组</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          <span class="comment">// 若是数组则要对每个成员进行依赖收集，若数组成员还是数组，则递归</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">            e = value[i]</span><br><span class="line">            e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 通过 getter 方法获得当前值（如果没有，就是 val），和新值比较，一致则不需要执行下面操作</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        <span class="comment">// 如果对象原本用 setter 方法则执行</span></span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 赋新值</span></span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新的值同样要进行 observe，保证数据响应式</span></span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line">      <span class="comment">// 派发更新 dep 对象通知所有观察者</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p><code>defineReactive</code> 方法将普通对象变成响应式对象，<strong>响应式对象 getter 相关的逻辑就是做依赖收集</strong></p>
<p>下面代码两个关键部分， 一个是 <code>const dep = new Dep()</code> 实例化一个 <code>Dep</code> 实例，另一个是 <code>get</code> 函数中通过 <code>dep.depend()</code> 做依赖收集</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化一个发布者 dep 用于收集订阅者 watcher</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了 getter 和 setter 钩子函数则将其去除</span></span><br><span class="line">  <span class="comment">// 新定义的 getter setter 会将其执行，保证不会将原来的覆盖</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象的子对象递归进行 observe 并返回子节点的 Observer 对象</span></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果对象原本具有 getter 方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集 将 watcher 添加到 dep 中该数据属性对应的订阅者数组</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">// 子对象进行依赖收集，其实是将同一个 watcher 观察者实例放入一个是当前 dep 中 该数据属性对应的订阅者数组，另一个是子元素 dep 中的 该数据属性对应的订阅者数组</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          <span class="comment">// 若是数组则要对每个成员进行依赖收集，若数组成员还是数组，则递归</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">            e = value[i]</span><br><span class="line">            e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><p><strong><code>Dep</code> 类有一个静态属性 <code>target</code>, 指向当前正被计算的 <code>watcher</code>, 因为同一时间只有一个 <code>watcher</code> 被计算，因此 <code>Dep.target</code> 指向的 <code>watcher</code> 是当前全局唯一的</strong>，自身属性 <code>subs</code> 是 <code>watcher</code> 数组</p>
<p><code>Dep</code> 和 <code>watcher</code> 其实是 观察者 设计模式的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">import</span> type Watcher <span class="keyword">from</span> <span class="string">'./watcher'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// subs 属性维护 watcher 数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个 观察者 watcher</span></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除一个 观察者 watcher</span></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖收集，当存在 Dep.target 时添加观察者 watcher</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// 调用 watcher 的 addDep，this 为 dep</span></span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者，调用 update()</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stablize the subscriber list first</span></span><br><span class="line">    <span class="comment">// 触发更新，遍历 subs 数组，调用 watcher 的 update 方法</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update() <span class="comment">// 遍历调用 watcher 的 update() ，最终调用 watcher 的 run()，执行 callback</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// this is globally unique because there could be only one</span></span><br><span class="line"><span class="comment">// watcher being evaluated at any time.</span></span><br><span class="line"><span class="comment">// Dep.target 指向当前被计算 watcher （全局唯一 watcher） ，同一时间只有一个 watcher 被计算</span></span><br><span class="line"><span class="comment">// 依赖收集完要将 Dep.target 设为 null，防止之后重复添加依赖</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 watcher 观察者实例设置为 Dep.target,用于依赖收集。同时将该实例放入 target 栈中</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 watcher 观察者实例从 target 栈中取出并设置给 Dep.taget</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><p>声明组件时使用的 watch，实际调用了 <code>new Watcher(a, callback)</code>, watcher 相当于一个观察者。接下来看一下 watcher 代码，看一下它是怎么和 Observer 关联的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/watcher/js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解析表达式，进行依赖收集的观察者，会在表达式数据更新时触发回调函数。通常用于 $watch api 和指令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  getter: <span class="built_in">Function</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component, // vm</span><br><span class="line">    expOrFn: string | Function, // 表达式</span><br><span class="line">    cb: Function, // 回调</span><br><span class="line">    options?: Object = &#123;&#125;</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// _watchers 存放订阅者实例 new Watcher(vm, ....)</span></span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">    <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">    <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">    <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">    <span class="keyword">this</span>.expression = expOrFn.toString()</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">      <span class="comment">// 初始化渲染 new Watcher(vm, () =&gt; vm._update(vm._render(), hydrating))</span></span><br><span class="line">      <span class="comment">// 此时 this.getter = () =&gt; vm._update(vm._render(), hydrating)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new Watcher() 时如果不是定义 lazy watcher 会调用 this.get()（pushTaget(this)），就是将自身 watcher 赋给 Dep.target 并调用 this.getter 求值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获得 getter 值并重新进行依赖收集</span></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">// 将自身 watcher 观察者实例设置给 Dep.target，用来依赖收集</span></span><br><span class="line">    <span class="comment">// 相当于 Dep.target = this(watcher)</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 调用 this.getter 对于初次渲染 this.getter = () =&gt; vm._upddate(vm._render(), hydrating)</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      <span class="comment">// 递归每个对象或者数组，触发它们的 getter，使得对象或数组的每一个成员都被依赖收集</span></span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将之前的观察者实例从 target 栈中取出并设置给 Dep.target</span></span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        <span class="comment">// 调用 dep 对象添加自身 watcher</span></span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// watcher 更新</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">// 同步则执行 run 方法 直接渲染视图</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异步推送到观察者队列中，下一个 tick 时调用</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获取观察者的值</span></span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h4><p>Vue 的 mount 过程核心是通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;, noop)</span><br><span class="line">hydrating = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>实例化一个渲染 <code>watcher</code> 时，首先进入 <code>wacher</code> 构造函数逻辑，执行 <code>this.get()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</span><br><span class="line">  <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">  <span class="comment">// dependencies for deep watching</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">    traverse(value)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">  <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行 <code>pushTarget(this)</code> 实际上是把将 <code>Dep.target</code> 指向的 <code>watcher</code> 先压栈(为了恢复用)，接着将<strong>自身赋值给 <code>Dep.target</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着执行 <code>value = this.getter.call(this.vm, this.vm)</code>, 此时 <code>this.getter</code> 对应的就是 <code>() =&gt; vm._update(vm._render(), hydrating)</code>,<br>实际就是执行 <code>vm._update(vm._render(), hydrating)</code></p>
<p>它首先执行 <code>vm._render()</code>, 内部通过 <code>render</code> 函数生成渲染 vnode，在这个过程上会对 vm 上的数据进行访问，就触发了数据对象的 getter</p>
<p>每个对象值的 getter 都有一个 <code>dep</code>, 在触发 getter 的时候会调用 <code>dep.depend()</code>，也就会执行 <code>Dep.target.addDep(this)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/watcher.js</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dep.target</code> 已经被赋值为 渲染 <code>watcher</code>, 这里主要是做一些逻辑判断（保证同一个数据不会被添加多次）后执行 <code>dep.addSub(this)</code>, 就会执行 <code>this.subs.push(sub)</code>，也就是把当前 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>subs</code> 中，目的是为后续数据变化时通知到哪些 <code>subs</code> 做准备</p>
<p>在 <code>vm._render()</code> 过程中，会触发所有数据的 getter，实际完成了依赖收集的过程。</p>
<p>回到 <code>get</code> 方法中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">  traverse(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val: any, seen?: Set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">if</span> (!seen) &#123;</span><br><span class="line">    seen = seenObjects</span><br><span class="line">    seen.clear()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">const</span> isO = isObject(val)</span><br><span class="line">  <span class="keyword">if</span> ((isA || isO) &amp;&amp; <span class="built_in">Object</span>.isExtensible(val)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">      <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">      <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        seen.add(depId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">      i = val.length</span><br><span class="line">      <span class="keyword">while</span> (i--) traverse(val[i], seen)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isO) &#123;</span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">      i = keys.length</span><br><span class="line">      <span class="keyword">while</span> (i--) traverse(val[keys[i]], seen)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是递归访问 <code>value</code>, 触发它所有子项的 <code>getter</code>，接下来执行 <code>popTarget()</code>，也就是 <code>Dep.target = targetStack.pop()</code>。实际上就是把 <code>Dep.target</code> 恢复成上一个状态，因为此时当前 vm 的数据依赖已经收集完成，对应的渲染 <code>Dep.target</code> 也需要改变。最后执行 <code>this.cleanupDeps()</code></p>
<h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><p>在给数据设置响应式，getter 进行依赖收集，目的就是修改数据时可以对相关的依赖派发更新</p>
<h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><p>setter 的核心逻辑有 2 个，一个是 <code>childOb = observe(newVal)</code>，会把新值变为响应式对象，另一个 <code>dep.notify()</code> 通知所有观察者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="过程分析-1"><a href="#过程分析-1" class="headerlink" title="过程分析"></a>过程分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observerdep.js/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对组件中的响应的数据进行修改会触发 setter 的逻辑，调用 <code>dep.notify()</code> 方法，遍历所有 <code>subs</code>，也就是 <code>watcher</code> 实例数组，然后调用每一个 <code>watcher</code> 的 <code>update</code> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">// 同步则执行 run 方法 直接渲染视图</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异步推送到观察者队列中，下一个 tick 时调用</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里针对 <code>watcher</code> 的不同状态，会执行不同的逻辑，在一般组件数据更新的场景，会走到最后一个 <code>queueWatcher(this)</code> 逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将一个观察者对象 watcher 推送到观察者队列中，如果队列中已经存在相同的 id 则跳过该观察者，除非是在队列被刷新时推送</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 watcher id</span></span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="comment">// 检验 watcher id，已经存在跳过该观察者，不存在则标记哈希 has 为 true，用于下次检验</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      <span class="comment">// 如果没有 flush 掉，watcher 添加到 队列中</span></span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="comment">// 当 flushing 为 true，会从后往前找，找到第一个等待插入的 watcher id 比当前队列中 watcher id 大的位置，把 watcher 按照 id 插入到队列中，因此 queue 队列的长度发生了变化</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(<span class="built_in">Math</span>.max(i, index) + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// nextTick 后执行 flushSchedulerQueue</span></span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入一个队列的概念，vue 派发更新的时候，并不会每次数据修改都触发 <code>watcher</code> 的回调，而是把这些 <code>watcher</code> 先添加都一个队列里，在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code>。同时 id 重复的 <code>watcher</code> 不会被多次添加到队列中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// nextTick 的回调，在下一个 tick 时 flush 掉队列同时运行 watcher</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  给 queue 队列排序，这样可以保证：</span></span><br><span class="line"><span class="comment">  1.组件更新的顺序是从父组件到子组件，应为父组件总是比子组件先创建</span></span><br><span class="line"><span class="comment">  2.一个组件的 user watcher 比 render watcher 先运行，因为 user watcher 往往比 render watcher 更早创建</span></span><br><span class="line"><span class="comment">  3.如果一个组件在父组件 watcher 运行期间被销毁，它的 watcher 执行将会被跳过</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="comment">// 这里不用 index = queue.length; index &gt; 0; index-- 的方式是因为不要将 length 进行缓存，因为在执行处理现有 watcher 对象期间，更多的 watcher 可能会被 push 进 queue 队列中</span></span><br><span class="line">  <span class="comment">// 队列遍历 执行 watcher run 方法 更新视图</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = queue[index]</span><br><span class="line">    <span class="keyword">const</span> id = watcher.id</span><br><span class="line">    <span class="comment">// 将 has 的标记清除</span></span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 调用 watcher run 方法 更新视图</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      在测试环境中，检测 watch 是否在死循环中</span></span><br><span class="line"><span class="comment">      如</span></span><br><span class="line"><span class="comment">      watch: &#123;</span></span><br><span class="line"><span class="comment">        test() &#123; this.test++ &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      持续执行了 100 次 watch 代表可能存在死循环</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; config._maxUpdateCount) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">'flush'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 状态恢复</span></span><br><span class="line">  resetSchedulerState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flushSchedulerQueue</code> <strong>是下一个 tick 时的回调函数，主要目的是执行 <code>watcher</code> 的 <code>run</code> 方法，用来更新视图</strong></p>
<p>这里主要有个三个核心逻辑：</p>
<ul>
<li>队列排序</li>
</ul>
<p><code>queue.sort((a, b) =&gt; a.id - b.id)</code> 对队列根据 id 从小到达进行排序，主要是保证：</p>
<p>1.组件更新的顺序是从父组件到子组件，应为父组件总是比子组件先创建<br>2.用户自定义的 <code>watcher</code> 比渲染 <code>watcher</code> 先运行，因为 user <code>watcher</code> 往往比渲染 <code>watcher</code> 更早创建<br>3.如果一个组件在父组件 <code>watcher</code> 运行期间被销毁，它的 <code>watcher</code> 执行将会被跳过，所以父组件的 <code>watcher</code> 应该先执行</p>
<ul>
<li>队列遍历</li>
</ul>
<p>对 <code>queue</code> 队列排序后，接着进行遍历，拿到对应 <code>watcher</code>，执行 <code>watcher.run()</code>。这里要注意，在遍历的时候每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 时，用户可能会再次添加新的 <code>watcher</code>，这样会再次执行 <code>queueWatcher</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 watcher id</span></span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="comment">// 检验 watcher id，已经存在跳过该观察者，不存在则标记哈希 has 为 true，用于下次检验</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      <span class="comment">// 如果没有 flush 掉，watcher 添加到 队列中</span></span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="comment">// 当 flushing 为 true，会从后往前找，找到第一个等待插入的 watcher id 比当前队列中 watcher id 大的位置，把 watcher 按照 id 插入到队列中，因此 queue 队列的长度发生了变化</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(<span class="built_in">Math</span>.max(i, index) + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>flushing</code> 为 true，会从后往前找，找到第一个等待插入的 <code>watcher</code> id 比当前队列中 <code>watcher</code> id 大的位置，把 <code>watcher</code> 按照 id 插入到队列中，因此 <code>queue</code> 队列的长度发生了变化</p>
<ul>
<li>状态恢复</li>
</ul>
<p><code>queueWatcher</code> 最后执行 <code>resetSchedulerState()</code>。逻辑就是清空 <code>watcher</code> 队列并把一些变量重置到初始值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset the scheduler's state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 清空 watcher 队列</span></span><br><span class="line">  queue.length = <span class="number">0</span></span><br><span class="line">  has = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>watcher.run()</code> 方法执行先通过 <code>this.get()</code> 得到它的当前值，然后判断如果满足新旧值不等、新值是对象类型、<code>deep</code> 模式中的任意一个条件，执行 <code>watcher</code> 的回调</p>
<p>这里 <code>watcher</code> 的回调函数执行时候会把第一个和第二个参数传入新值 <code>value</code> 和旧值 <code>oldValue</code>, 因此在组件中添加自定义 <code>watcher</code> 的时候可以在回调函数的参数中拿到新旧值</p>
<p>对于渲染 <code>watcher</code>, 执行 <code>this.get()</code>，会执行 <code>getter</code> 方法，也就是传入的第二个参数 <code>() =&gt; vm._update(vm._render(), hydrating)</code>, 因此修改组件相关的响应式数据时，会触发组件重新渲染，重新执行 <code>patch</code> 过程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/watcher.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">              <span class="string">`Error in watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>,</span><br><span class="line">              <span class="keyword">this</span>.vm</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">            <span class="keyword">if</span> (config.errorHandler) &#123;</span><br><span class="line">              config.errorHandler.call(<span class="literal">null</span>, e, <span class="keyword">this</span>.vm)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><h4 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h4><p><strong>JS 执行是单线程的，它是基于事件循环</strong>。事件循环大致分为以下几个步骤</p>
<ul>
<li><strong>所有同步任务都是在主线程上执行，形成一个执行栈（execution context stack）</strong></li>
<li><strong>主线程之外，还存在一个“任务队列”（task queue）。只要异步任务有了运行结果，会在“任务队列”中放置一个事件</strong></li>
<li><strong>一旦“执行栈”中所有同步任务执行完毕，系统会读取“任务队列”，看有哪些事件。那些对应的异步任务于是结束等待状态，进入执行栈开始执行</strong></li>
<li>主线程不断重复上述三个步骤</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-14/25554080.jpg" alt=""></p>
<p><strong>主线程的执行过程就是一个 tick</strong>, 所有的异步结果都是通过任务队列来调度。规范中规定 <strong>异步 task 分为两大类，分别是 macro task（宏任务）和 micro task（微任务），并且每个 macro task（宏任务） 结束后，都要清空所有的 micro task（微任务）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (macroTask <span class="keyword">of</span> macroTaskQueue) &#123;</span><br><span class="line">  <span class="comment">// 1. 处理当前 macro task 宏任务</span></span><br><span class="line">  handleMacroTask()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 处理全部 micro task 微任务</span></span><br><span class="line">  <span class="keyword">for</span> (microTask <span class="keyword">of</span> microTaskQueue) &#123;</span><br><span class="line">    handleMicroTask(microTask)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器环境中，常见的 macro task（宏任务） 有 <code>setTimout</code> <code>MessageChannel</code> <code>postMessage</code> <code>setImmediate</code> <code>Ajax</code>; 常见的 micro task（微任务）有 <code>MutationObserver</code> <code>Promise</code> <code>process.nextTick</code></p>
<h4 id="Vue-中-nextTick"><a href="#Vue-中-nextTick" class="headerlink" title="Vue 中 nextTick"></a>Vue 中 nextTick</h4><p><code>nextTick</code> 的目的就是产生一个回调函数加入 macro task 或 micro task 中，当执行栈执行完后调用该回调函数，起到异步触发（下一个 tick 触发）的目的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/util/env.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defer a task to execute it asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  延迟一个任务使其异步执行，在下一个 tick 时执行，一个立即执行函数，返回一个 function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放异步执行的回调</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line">  <span class="comment">// 一个标记位，如果已经有 timerFunc 被推送到任务队列中则不需要重复推送</span></span><br><span class="line">  <span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 一个函数指针，指向函数被推送到任务队列中，等到主线程任务执行完，任务队列中的 timerFunc 被调用</span></span><br><span class="line">  <span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个 tick 时的回调</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一个标记位，标记等待状态（即函数已经被推入到任务队列或主线程，已经在等待当前栈执行完毕去执行）</span></span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 执行所有 callback</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">      copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line">  <span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line">  <span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line">  <span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line">  <span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line">  <span class="comment">// Promise is available, we will use it:</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一共有 Promise、MutationObserver 和 setTimeout 三种尝试得到 timerFunc 的方法</span></span><br><span class="line"><span class="comment">    优先使用 Promise，在 Promise 不存在的情况下使用 MutationObserver，这两种方法都会在 micro task(微任务)中执行，会比 setTimout（属于 macro task 宏任务） 更早执行</span></span><br><span class="line"><span class="comment">    如果上述两种方法都不执行的环境会使用 setTimeout，在 macro task 尾部推入这个函数，等待调用执行</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve() <span class="comment">// 返回一个 promise</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      p.then(nextTickHandler)</span><br><span class="line">      <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">      <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">      <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">      <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">      <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">      <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">  )) &#123;</span><br><span class="line">    <span class="comment">// use MutationObserver where native Promise is not available,</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS IE11, iOS7, Android 4.4</span></span><br><span class="line">    <span class="comment">// 新建一个 textNode 的 dom 对象，用 MutationObserver 绑定该 dom 并执行回调函数，在 dom 变化时候回触发回调，该回调会进入主线程（比 macro task 优先执行）</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">    observer.observe(textNode, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">      textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fallback to setTimeout</span></span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="comment">// 使用 setTimeout 将回调推入 macro task 队列尾部</span></span><br><span class="line">    timerFunc = setTimeout</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    推动到队列中下一个 tick 时执行</span></span><br><span class="line"><span class="comment">    cb 回调函数</span></span><br><span class="line"><span class="comment">    ctx 上下文</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> func = ctx</span><br><span class="line">      ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; cb.call(ctx) &#125;</span><br><span class="line">      : cb</span><br><span class="line">    <span class="comment">// cb 存到 callbacks 中</span></span><br><span class="line">    callbacks.push(func)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span></span><br><span class="line">      timerFunc(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>之前 <code>watcher.run()</code> 异步会执行 <code>queueWatcher(this)</code>, 最终会执行 <code>nextTick(flushSchedulerQueue)</code>。</p>
<p><code>nextTick</code> 函数是一个立即执行函数，返回 <code>queueNextTick</code> 函数。<code>queueNextTick</code> 方法的逻辑很简单，就是将传入的 <code>cb</code> 放入 <code>callbacks</code> 数组，然后执行 <code>timerFunc</code>(pending 是一个状态标记，用于保证 timerFunc 在下一个 tick 之前只执行一次)</p>
<blockquote>
<p><strong><code>timerFunc</code> 其实是一个异步函数的实现，在该异步函数内部遍历 <code>callbacks</code> 中的 <code>cb</code> 并执行 <code>cb</code>。对于不同的环境实现 <code>timerFunc</code>, 会按照支持 Promise、MutationObserver、setTimeout 的先后顺序（前两者都属于 micro task 微任务，比 属于 macro task 宏任务 的 setTimeout 执行快）来实现封装一个异步方法。<code>timerFunc</code> 作为异步回调最后会加入 micro task 或 macro task 中，在执行栈执行完毕后调用该回调函数，起到了异步触发（下一个 tick）的目的</strong></p>
</blockquote>
<p><code>nextTick(flushSchedulerQueue)</code> 最后不论内部是用 Promise MutationOBserver 还是 setTimeout 封装 <code>timerFunc</code>, 它们都会在下一个 tick 执行 <code>flushSchedulerQueue</code>, 也就是对 <code>callbacks</code> 遍历，执行对应的回调函数</p>
<h3 id="vue-中检测变化的问题"><a href="#vue-中检测变化的问题" class="headerlink" title="vue 中检测变化的问题"></a>vue 中检测变化的问题</h3><h4 id="响应式对象新添加的属性"><a href="#响应式对象新添加的属性" class="headerlink" title="响应式对象新添加的属性"></a>响应式对象新添加的属性</h4><p>vue 中使用 <code>Object.defineProperty</code> 实现对象的响应式，对于响应式对象对象直接添加新的属性时，因为没有添加 getter setter，是无法做到响应式。vue 提供了 <code>vm.$set(obj, key, value)</code> <code>Vue.set(obj, key, value)</code> 方法向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，并且触发视图更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment"> * triggers change notification if the property doesn't</span></span><br><span class="line"><span class="comment"> * already exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">obj: Array&lt;any&gt; | Object, key: any, val: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123;</span><br><span class="line">    <span class="comment">// splice 方法不只是原型数组的原型方法</span></span><br><span class="line">    <span class="comment">// 数组的话通过下标插入</span></span><br><span class="line">    obj.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 key 已经存在直接复制返回</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(obj, key)) &#123;</span><br><span class="line">    obj[key] = val</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = obj.__ob__</span><br><span class="line">  <span class="keyword">if</span> (obj._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> +</span><br><span class="line">      <span class="string">'at runtime - declare it upfront in the data option.'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在，说明之前 obj 不是响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    obj[key] = val</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用 defineReactive 将对象设置为响应式</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  <span class="comment">// 手动触发依赖通知</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>set</code> 方法接受三个参数，<code>obj</code> 可能是数组或者是普通对象，<code>key</code> 代表数组下标或者是对象的键值，<code>val</code> 添加的值</p>
<ul>
<li>首先判断 <code>obj</code> 数组并且 <code>key</code> 是合法下标，则通过 <code>splice</code> 去添加进数组然后返回，注意这里的 <code>splice</code> 不仅仅是原生数组的原型方法</li>
<li>接着判断 <code>key</code> 已经存在则直接赋值返回</li>
<li>接着在获取 <code>obj.__ob__</code> 并赋值给 <code>ob</code>, 之前分析它是在 <code>Observer</code> 构造函数执行时候初始化，表示 <code>Observer</code> 的一个实例，如果它不存在，说明 <code>obj</code> 不是一个响应式对象，直接赋值返回</li>
<li>最后通过 <code>defineReactive(ob.value, key, val)</code> 把新添加的属性变成响应式对象，再通过 <code>ob.dep.notify()</code> 手动触发依赖通知</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><code>Object.defineProperty</code> 无法检测到数组的变化，vue 内部下面对 7 中数组原型方法做了 hack，只支持：</p>
<ul>
<li>push</li>
<li>pop</li>
<li>shift</li>
<li>unshift</li>
<li>reverse</li>
<li>sort</li>
<li>splice</li>
</ul>
<p>对于利用索引值直接设置一个项 <code>vm.items[index] = newVal</code>, 可以使用 <code>Vue.set(example.items, index, newVal)</code>; 对于修改数组的长度 <code>vm.items.length = newLength</code>, 可以使用 <code>vm.items.splice(newLength)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 判断对象是否有 __proto__, 存在 augment 指向 protoAugment，否则指向 copyAugment</span></span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment an target Object or Array by intercepting</span></span><br><span class="line"><span class="comment"> * the prototype chain using __proto__</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// const arrayKeys = Object.getOwnPropertyNames(arrayMethods)</span></span><br><span class="line"><span class="comment">// protoAugment(value, arrayMethods, arrayKeys)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment an target Object or Array by defining</span></span><br><span class="line"><span class="comment"> * hidden properties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * istanbul ignore next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// const arrayKeys = Object.getOwnPropertyNames(arrayMethods)</span></span><br><span class="line"><span class="comment">// copyAugment(value, arrayMethods, arrayKeys)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化 <code>Observer</code> 时，它的构造函数中对数组做了处理，首先通过 <code>hasProto</code> 判断对象中是否有 <code>__proto__</code>, 有则 <code>augment</code> 指向 <code>protoAugment</code>, 否则 <code>augment</code> 指向 <code>protoAugment</code></p>
<p><code>protoAugment</code> 方法直接将 <code>target.__proto__</code> 原型修改为 <code>src</code>; <code>copyAugment</code> 方法是遍历 keys，通过 <code>def</code>，也就是 <code>Object.defineProperty</code> 定义它自身的属性值。大部分现代浏览器都会执行 <code>protoAugment</code>, 它实际就是将 <code>value</code> 的原型指向 <code>arrayMethods</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/array.js</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * not type checking this file because flow doesn't play well with</span></span><br><span class="line"><span class="comment"> * dynamically accessing methods on Array prototype</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="comment">// arrayMethods 继承 Array</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">;[</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// avoid leaking arguments:</span></span><br><span class="line">    <span class="comment">// http://jsperf.com/closure-with-arguments</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">arguments</span>.length</span><br><span class="line">    <span class="keyword">const</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(i)</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原有方法先执行</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取插入值，将添加值变成响应式对象</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    <span class="comment">// 手动触发依赖通知</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>arrayMethods</code> 首先继承 <code>Array</code>，然后对 <code>push</code> <code>pop</code> <code>shift</code> <code>unshift</code> <code>splice</code> <code>sort</code> <code>reverse</code> 7 种方法进行重写，<strong>重写的方法先执行原有逻辑，并对增加数组长度的三种方法 <code>push</code> <code>pop</code> <code>splice</code> 进行判断，获取插入的值，然后将新添加的值变成一个响应式对象，并且调用 <code>ob.dep.notify()</code> 手动触发依赖通知</strong></p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性一般只用到 getter，但是计算属性并不是简单的 getter，它会更新它的依赖列表并缓存结果。只要依赖不发生变化，访问计算属性会直接返回缓存的结果，而不是调用 getter</p>
<p>vue 实例初始化阶段 <code>initState</code> 方法初始化了 <code>data</code> <code>props</code> <code>computed</code> <code>watch</code> <code>methods</code></p>
<p><strong>整个计算属性的初始化就是利用 <code>Object.defineProperty</code> 为计算属性对应 key 值添加 getter setter。初始化 <code>computed</code> 时候，会先将 <code>computed</code> 对应 key 的函数先创建一个 <code>watcher</code>, 再对该计算属性使用 <code>Object.defineProperty</code> 为计算属性对应 key 添加 getter setter，<code>watcher</code> 作为该 key 的 getter</strong>。setter 在平常的开发场景下情况比较少，也不推荐使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  initProps(vm)</span><br><span class="line">  initData(vm)</span><br><span class="line">  initComputed(vm)</span><br><span class="line">  initMethods(vm)</span><br><span class="line">  initWatch(vm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computedSharedDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  get: noop,</span><br><span class="line">  set: noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> computed = vm.$options.computed</span><br><span class="line">  <span class="keyword">if</span> (computed) &#123;</span><br><span class="line">    <span class="comment">// 遍历 computed 对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">      <span class="comment">// 拿到计算属性的每一个 userDef</span></span><br><span class="line">      <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 userDep 不是 function（认为是 getter 函数）, 用 userDep 创建一个 watcher</span></span><br><span class="line">        computedSharedDefinition.get = makeComputedGetter(userDef, vm)</span><br><span class="line">        computedSharedDefinition.set = noop</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 userDep 不是 function， 尝试获取 userDef 对应的 getter 函数，为该 getter 函数创建一个 watcher</span></span><br><span class="line">        computedSharedDefinition.get = userDef.get</span><br><span class="line">          ? userDef.cache !== <span class="literal">false</span></span><br><span class="line">            ? makeComputedGetter(userDef.get, vm)</span><br><span class="line">            : bind(userDef.get, vm)</span><br><span class="line">          : noop</span><br><span class="line">        computedSharedDefinition.set = userDef.set</span><br><span class="line">          ? bind(userDef.set, vm)</span><br><span class="line">          : noop</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为计算属性对应 key 添加 getter 和 setter</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(vm, key, computedSharedDefinition)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeComputedGetter</span> (<span class="params">getter: Function, owner: Component</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 参数 getter 为 用户自定义的计算属性 get 方法</span></span><br><span class="line">  <span class="comment">// 参数 owner 为 当前 vm 实例</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(owner, getter, noop, &#123;</span><br><span class="line">    <span class="comment">// 表明该 watcher 的求值被延迟，不会在初始化时求值</span></span><br><span class="line">    <span class="comment">// 设置 lazy 为 true，也就是设置 dirty 为 true</span></span><br><span class="line">    lazy: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 返回 computedGetter 方法，访问 vm 上的计算属性会调用该方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 watcher.dirty 为 true，会调用 watcher.evaluate 对 watcher 进行计算</span></span><br><span class="line">    <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">      <span class="comment">// watcher.evaluate 方法通过 this.get 方法对 watcher 进行求值，接着设置 this.dirty 为 false，当下次访问 vm 上的计算属性时，watcher.dirty 为 false，就不会再次对 watcher 进行求值，因此也不再次访问计算属性的 getter</span></span><br><span class="line">      watcher.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="comment">// 当计算属性的依赖改变时，会触发依赖的 setter，也就会调用 watcher 的 update 方法，将 watcher 的 dirty 属性设置 true。当访问计算属性时会对 watcher 重新求值</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      watcher.depend()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> watcher.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/watcher.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object = &#123;&#125;</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// computed watcher 初始化设置 this.dirty 为 true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// computed watcher 初始化不会立即求值，但同时持有一个 dep 实例</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="comment">// lazy watcher 设置 dirty 为 true</span></span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">// 同步调用 run 方法</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异步放入 watcher 队列</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="comment">// 通过 this.get 方法对 watcher 进行求值, 同时设置 this.dirty 为 false</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initComputed</code> 方法对 <code>computed</code> 属性进行遍历，拿到每个计算属性的定义。计算属性的定义可以是一个 function，也可以是一个 object。默认是一个 function，只有 get 方法，如果想设置计算属性的 set 方法或设置 cache 为 false，则要把计算属性顶一个 object。计算属性的 get 方法默认是通过 <code>makeComputedGetter</code> 方法实现，除非设置 cache 为 false。最后通过 <code>Object.defineProperty(this, key, def)</code> 方法吧每个计算属性绑定到 vm 实力上，访问 vm 上的计算属性会调用 <code>def.get</code> 方法</p>
<p>而初始化该 <code>computed watcher</code> 实例时，<code>computed watcher</code> 不会立即求值。<code>computed watcher</code> 初始化设置 <code>lazy</code> 为 true，也就是设置 <code>dirty</code> 为 true。第一次访问 vm 上的计算属性，会调用计算属性的 getter，此时 <code>watcher.drity</code> 为 true。<strong><code>watcher.evaluate</code> 方法通过 <code>this.get</code> 方法对 <code>watcher</code> 进行求值，接着设置 <code>this.dirty</code> 为 false，当下次访问 vm 上的计算属性时，<code>watcher.dirty</code> 为 false，就不会再次对 <code>watcher</code> 进行求值，因此也不再次访问计算属性的 getter</strong></p>
<p>为何修改计算属性的依赖时候，getter 方法会再次被调用？<strong>因为在第一次调用计算属性的 getter 时，<code>watcher.depend()</code> 会将当前 watcher 订阅到依赖中。当依赖被修改时。会触发依赖的 setter 方法，也就会调用 <code>watcher</code> 的 <code>update</code> 方法。因为 <code>computed watcher</code> 是 <code>lazy watcher</code> ，因此这时 <code>watcher</code> 的 <code>dirty</code> 属性设置 true。当再次访问计算属性，会重新调用 <code>watcher.evaluate</code> 方法对 watcher 进行求值，因此计算属性的 getter 方法被再次调用</strong></p>
<h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><h3 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h3><p><code>new Vue()</code> 调用了构造函数中的 <code>this._init()</code>, <code>this._init()</code> 最后调用了 <code>initRender()</code>,  <code>initRender()</code> 最后执行 <code>vm.$mount()</code></p>
<p><code>$mount</code> 方法在多个文件中都有定义，<code>src/entries/web-runtime-with-compiler.js</code>、<code>src/entries/web-runtime.js</code> 等。我们重点分析带有 <code>compiler</code> 版本的 <code>$mount</code> 实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/entries/web-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> 可以是 css 选择器也可以是 HTML 元素（dom）</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">/*</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    index.html 模板有 &lt;div id="#app"&gt;&lt;/</span>div&gt;；入口文件 new Vue(&#123;el: <span class="string">'#app'</span>&#125;</span>) 等同于 <span class="title">new</span> <span class="title">Vue</span>(<span class="params">&#123;&#125;</span>).<span class="title">$mount</span>(<span class="params"><span class="string">'#app'</span></span>)</span></span><br><span class="line"><span class="function">    或者</span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">div</span> = <span class="title">document</span>.<span class="title">createElement</span>(<span class="params"><span class="string">'div'</span></span>); <span class="title">div</span>.<span class="title">id</span> = '#<span class="title">app</span>';<span class="title">document</span>.<span class="title">body</span>.<span class="title">appendChild</span>(<span class="params">div</span>);</span></span><br><span class="line"><span class="function">    <span class="title">new</span> <span class="title">Vue</span>(<span class="params">&#123;el: div&#125;</span>) 等同 <span class="title">new</span> <span class="title">Vue</span>(<span class="params">&#123;&#125;</span>).<span class="title">$mount</span>(<span class="params">div</span>)</span></span><br><span class="line"><span class="function">  */</span></span><br><span class="line"><span class="function">  <span class="title">hydrating</span>?: <span class="title">boolean</span></span></span><br><span class="line"><span class="function">): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">// el 不能挂载在 html body 这样的根节点上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="comment">// 如果 vue 实例选项中 render 属性不存在，将 template / el 转化为 render 函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">let</span> isFromDOM = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 如果 vue 实例选项中存在 template 属性</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          isFromDOM = <span class="literal">true</span></span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        isFromDOM = <span class="literal">true</span></span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 如果 vue 实例选项中 template 属性不存在，将 el 的 outerHTMl 作为 模板</span></span><br><span class="line">      isFromDOM = <span class="literal">true</span></span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">// 通过 compileToFunctions 方法将 template （无论 template 属性值 还是 el 的 outerHTML）转为 render 函数</span></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        warn,</span><br><span class="line">        isFromDOM,</span><br><span class="line">        shouldDecodeTags,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        delimiters: options.delimiters</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// 将 render 函数挂载到 vm.$options.render 属性</span></span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码首先缓存原先原型上的 <code>$mount</code> 方法（<code>src/entries/web-runtime.js</code> 中定义），再重新定义该方法</p>
<ul>
<li>首先对 <code>el</code> 做出限制，不能挂载在 <code>body</code>、<code>html</code> 这样的根节点上</li>
<li>核心逻辑是，对于没有定义 <code>render</code> 方法，会将 <code>template</code> 字符串，如果还没有 <code>template</code> 属性，会将 <code>el</code> 的 outerHTML 转为 <code>render</code> 函数</li>
</ul>
<blockquote>
<p><strong>Vue 2.0 中所有 vue 组件的渲染都需要 render 函数，不管是单文件组件 .vue 文件，还是 el 或者 template 属性，最终都会通过 compileToFunctions 方法转为 render 函数</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/entries/web-runtime.js</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; !config._isServer ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 调用 vm._mount</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._mount(el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原先原型上的 <code>$mount</code> 方法，第一个参数是 <code>el</code>, 在浏览器环境下回调用 <code>query</code> 方法转换为 dom 对象，第二个参数和服务端渲染有关，在浏览器环境下不需要传递</p>
<p><code>$mount</code> 方法实际调用 <code>src/core/instance/lifecycle.js</code> 下的 <code>_mount</code> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecycle.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: Element | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">  <span class="comment">// 初始化渲染 watcher，</span></span><br><span class="line">  vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 调动 vm._render, 通过 render 函数返回 vnode</span></span><br><span class="line">    <span class="comment">// 首次渲染 和 每次数据属性更新会执行该 watcher 中的回调，执行 vm._update() 对 vnode 进行 diff 和 patch</span></span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;, noop)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// root instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$root === vm) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>_mount</code> 方法核心先调用 <code>vm._render</code> 方法先生成 vnode，再实例化一个渲染 <code>watcher</code>，在它的回调函数中将 <code>vm._render</code> 返回的 vnode 传入 <code>vm._update</code> 调用更新 dom</p>
<blockquote>
<p><code>watcher</code> 在这里起到两个作用</p>
<ul>
<li><strong>初始化会执行回调函数</strong></li>
<li><strong>当 vm 实例中监听的数据发生变化时会执行回调函数</strong></li>
</ul>
</blockquote>
<p>函数最后判断为根节点的时候设置 <code>vm._isMounted</code> 为 <code>true</code>, 表示实例已经挂载，同时执行 <code>mounted</code> 钩子函数</p>
<h3 id="编译-render-函数"><a href="#编译-render-函数" class="headerlink" title="编译 render 函数"></a>编译 render 函数</h3><h4 id="render-函数概念"><a href="#render-函数概念" class="headerlink" title="render 函数概念"></a>render 函数概念</h4><p><code>render 函数</code> 是通过编译模板(<code>template</code> 或 <code>el</code> 的 outerHTML)得到，其运行结果是 vnode</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>I am a template!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"message"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No message.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Vue.compile(template)</code> 编译上面的模板会返回一个对象，对象中含有 <code>render</code> 和 <code>staticRenderFns</code> 两个值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的 render 函数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> _c( <span class="comment">// _c 为 createElement 方法(创建元素)</span></span><br><span class="line">      <span class="string">'div'</span>, <span class="comment">// 创建一个 div 元素</span></span><br><span class="line">      &#123;</span><br><span class="line">        attrs:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125; <span class="comment">// div 添加属性 id</span></span><br><span class="line">      &#125;,</span><br><span class="line">      [ <span class="comment">// _m 为 renderStatic 方法（渲染静态节点）</span></span><br><span class="line">        _m(<span class="number">0</span>), <span class="comment">// 这里为静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数</span></span><br><span class="line">        _v(<span class="string">" "</span>), <span class="comment">// _v 为 createTextNode 方法(创建文本 dom) 这里为空的文本节点</span></span><br><span class="line">        (message) <span class="comment">// 三元表达式，判断 message 是否存在</span></span><br><span class="line">          <span class="comment">// 存在就创建 p 元素，元素里有文本，值为 toString(message)</span></span><br><span class="line">          ? _c(<span class="string">'p'</span>,[_v(_s(message))]) <span class="comment">// _s 为 toString 方法（转为字符串）</span></span><br><span class="line">          <span class="comment">// 不存在就创建 p 元素，元素里文本值为 No message.</span></span><br><span class="line">          :_c(<span class="string">'p'</span>,[_v(<span class="string">"No message."</span>)])</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了 <code>render</code> 函数，还有一个 <code>staticRenderFns</code> 数组，这个数组中的函数和 vnode 中 diff 算法优化有关，会在比编译阶段给之后不会发生变化的 vnode 打上 <code>static</code> 为 <code>true</code> 的标签，那些被标记为静态节点的 vnode 会单独生成 <code>staticRenderFns</code> 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//上面 render 函数 中的 _m(0) 会调用这个方法</span></span><br><span class="line">  <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> _c(</span><br><span class="line">      <span class="string">'header'</span>,</span><br><span class="line">      [</span><br><span class="line">        _c(</span><br><span class="line">          <span class="string">'h1'</span>,</span><br><span class="line">          [</span><br><span class="line">            _v(<span class="string">"I'm a template!"</span>)</span><br><span class="line">          ]</span><br><span class="line">        )</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="编译-render-函数过程"><a href="#编译-render-函数过程" class="headerlink" title="编译 render 函数过程"></a>编译 render 函数过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/entries/web-runtime-with-compiler.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">  warn,</span><br><span class="line">  isFromDOM,</span><br><span class="line">  shouldDecodeTags,</span><br><span class="line">  shouldDecodeNewlines,</span><br><span class="line">  delimiters: options.delimiters</span><br><span class="line">&#125;, <span class="keyword">this</span>)</span><br><span class="line">options.render = render</span><br><span class="line">options.staticRenderFns = staticRenderFns</span><br></pre></td></tr></table></figure>
<p><code>src/entries/web-runtime-with-compiler.js</code> 中 <code>$mount</code> 方法通过调用  <code>compileToFunctions</code> 方法, 把模板 <code>template</code> 编译生成 <code>render</code> 以及 <code>staticRenderFns</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/platforms/web/compiler/index.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; compile <span class="keyword">as</span> baseCompile &#125; <span class="keyword">from</span> <span class="string">'compiler/index'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  options = options</span><br><span class="line">    ? extend(extend(&#123;&#125;, baseOptions), options)</span><br><span class="line">    : baseOptions</span><br><span class="line">  <span class="comment">// 合并参数，返回</span></span><br><span class="line">  <span class="keyword">return</span> baseCompile(template, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: CompilerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledFunctionResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _warn = (options &amp;&amp; options.warn) || warn</span><br><span class="line">  <span class="comment">// detect possible CSP restriction</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return 1'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.toString().match(<span class="regexp">/unsafe-eval|CSP/</span>)) &#123;</span><br><span class="line">        _warn(</span><br><span class="line">          <span class="string">'It seems you are using the standalone build of Vue.js in an '</span> +</span><br><span class="line">          <span class="string">'environment with Content Security Policy that prohibits unsafe-eval. '</span> +</span><br><span class="line">          <span class="string">'The template compiler cannot work in this environment. Consider '</span> +</span><br><span class="line">          <span class="string">'relaxing the policy to allow unsafe-eval or pre-compiling your '</span> +</span><br><span class="line">          <span class="string">'templates into render functions.'</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> key = options &amp;&amp; options.delimiters</span><br><span class="line">    ? <span class="built_in">String</span>(options.delimiters) + template</span><br><span class="line">    : template</span><br><span class="line">  <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="comment">// 传入 template，调用 compile 方法编译</span></span><br><span class="line">  <span class="keyword">const</span> compiled = compile(template, options)</span><br><span class="line">  <span class="comment">// 得到 render 函数的字符串后，通过 new Function 得到真正的渲染函数</span></span><br><span class="line">  res.render = makeFunction(compiled.render)</span><br><span class="line">  <span class="keyword">const</span> l = compiled.staticRenderFns.length</span><br><span class="line">  res.staticRenderFns = <span class="keyword">new</span> <span class="built_in">Array</span>(l)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.render === noop || res.staticRenderFns.some(<span class="function"><span class="params">fn</span> =&gt;</span> fn === noop)) &#123;</span><br><span class="line">      _warn(</span><br><span class="line">        <span class="string">`failed to compile template:\n\n<span class="subst">$&#123;template&#125;</span>\n\n`</span> +</span><br><span class="line">        detectErrors(compiled.ast).join(<span class="string">'\n'</span>) +</span><br><span class="line">        <span class="string">'\n\n'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunction</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将函数字符串生成函数并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> noop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compileToFunctions</code> 方法接受三个参数：编译模板 <code>template</code>、编译配置 <code>options</code>。核心的编译过程就是 <code>const compiled = compile(template, options)</code></p>
<p><code>compile</code> 函数执行的逻辑是先处理配置参数，真正的编译过程是 <code>return baseCompile(template, options)</code></p>
<p><code>baseCompile</code> 方法在 <code>src/compiler/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/compiler/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析模板字符串生成 AST 树</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line">  <span class="comment">// 优化语法树</span></span><br><span class="line">  optimize(ast, options)</span><br><span class="line">  <span class="comment">// 生成代码</span></span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)</span><br><span class="line">  <span class="comment">// 输出包含 AST、render 函数字符串、staticRenderFns 字符串的对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>parse</code> 函数（<code>src/compiler/parse/index.js</code> 中定义）主要作用是将模板字符串 <code>template</code> 里的结构(指令、属性、标签等)转为 AST 形式存进 ASTElement 中，最后解析生成 AST</strong>。整个 parse 的过程是利用<strong>正则表达式顺序解析模板</strong>，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。AST 元素节点总共有 3 种类型，type 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本。</p>
<p><strong><code>optimize</code> 函数（<code>src/compiler/optimizer.js</code> 中定义）主要功能就是标记静态节点，为后面的 <code>patch</code> 过程对比新旧 vnode 结构做优化。被标记为 static 的节点在后面的 diff 算法被直接忽略，不做详细比较</strong> (vue 是数据驱动，响应式的，但是应用中的数据并不全是响应式，很多数据是首次渲染就永远不会变化，那么这部分数据生成的 dom 也不会变化，可以再 <code>diff</code> <code>patch</code> 过程跳过对比)</p>
<p><strong><code>generate</code> 函数主要功能就是根据 AST 结构拼接生成 <code>render 函数</code> 的字符串</strong></p>
<blockquote>
<p>总结：render 函数编译过程</p>
</blockquote>
<ul>
<li>解析模板字符串（<code>template</code> 、<code>el</code> outerHTML）生成 AST <code>const ast = parse(template.trim(), options)</code></li>
<li>优化语法树  <code>optimize(ast, options)</code></li>
<li>生成代码  <code>const code = generate(ast, options)</code></li>
</ul>
<h2 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h2><p>vue 2.0 引入 虚拟 dom，算法来源于 snabbdom。dom 的操作是十分昂贵的，虚拟 dom 对 dom 做了一层映射，将直接对 dom 的一系列操作，映射到操作虚拟 dom。虚拟 dom 上定义了真实 dom 上的一些关键信息</p>
<h3 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h3><p>首先来看一下 <code>src/core/vdom/vnode.js</code> 中 vnode 的定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VNodeData 类型定义</span></span><br><span class="line"><span class="keyword">export</span> interface VNodeData &#123;</span><br><span class="line">  key?: string | number;</span><br><span class="line">  slot?: string;</span><br><span class="line">  ref?: string;</span><br><span class="line">  tag?: string;</span><br><span class="line">  staticClass?: string;</span><br><span class="line">  class?: any;</span><br><span class="line">  style?: <span class="built_in">Object</span>[] | <span class="built_in">Object</span>;</span><br><span class="line">  props?: &#123; [key: string]: any &#125;;</span><br><span class="line">  attrs?: &#123; [key: string]: any &#125;;</span><br><span class="line">  domProps?: &#123; [key: string]: any &#125;;</span><br><span class="line">  hook?: &#123; [key: string]: <span class="built_in">Function</span> &#125;;</span><br><span class="line">  on?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">  nativeOn?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">  transition?: <span class="built_in">Object</span>;</span><br><span class="line">  show?: boolean;</span><br><span class="line">  inlineTemplate?: &#123;</span><br><span class="line">    render: <span class="built_in">Function</span>;</span><br><span class="line">    staticRenderFns: <span class="built_in">Function</span>[];</span><br><span class="line">  &#125;;</span><br><span class="line">  directives?: VNodeDirective[];</span><br><span class="line">  keepAlive?: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/vdom/vnode.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: Array&lt;VNode&gt; | void,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    ns?: string | void,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 当前节点的标签名</span></span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="comment">// 当前节点对应的对象，包含具体的一些数据，VNodeData 类型</span></span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="comment">// 当前节点的子节点，是一个数组</span></span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="comment">// 当前节点的文本</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">// 当前虚拟节点对应的真实 dom 节点</span></span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="comment">// 当前节点的命名空间</span></span><br><span class="line">    <span class="keyword">this</span>.ns = ns</span><br><span class="line">    <span class="comment">// 当前节点的编译作用域</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="comment">// 节点的 key 属性，被当做节点的标识，用于优化</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="comment">// 组件的 options 选项</span></span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="keyword">this</span>.child = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 当前节点的父节点</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 是否是原生 html 还是普通文本，innerHTML 时候为 true，textContent 为 false</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 是否为静态节点</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 是否作为根节点插入</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 是否为注释节点</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 是否为克隆节点</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>每一个 vnode 都会映射到一个真实 dom 节点，其中有几个比较重要的属性：</p>
<ul>
<li><code>tag</code> vnode 的标签属性</li>
<li><code>data</code> 包含了最终渲染成真实 dom 节点上的 class attribute style 以及绑定的事件等</li>
<li><code>children</code> vnode 的子节点，是一个数组</li>
<li><code>text</code> 文本属性</li>
<li><code>elm</code> vnode 对应的真实 dom 节点</li>
<li><code>key</code> vnode 的标记，有利于优化</li>
</ul>
<p><strong>vnode 简单理解就是使用 js 对象来描述一个 dom 结构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    id: <span class="string">'app'</span>,</span><br><span class="line">    class: 'main'</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    tag: <span class="string">'p'</span>,</span><br><span class="line">    text: <span class="string">'hello'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终渲染成的 dom</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>vue 中使用 <code>createElement</code> 方法创建 vnode</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-element.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// wrapper function for providing a more flexible interface</span></span><br><span class="line"><span class="comment">// without getting yelled at by flow</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: any</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data &amp;&amp; (<span class="built_in">Array</span>.isArray(data) || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>)) &#123;</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// make sure to use real instance instead of proxy as context</span></span><br><span class="line">  <span class="keyword">return</span> _createElement(<span class="keyword">this</span>._self, tag, data, children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string | Class&lt;Component&gt; | Function | Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  data?: VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  children?: VNodeChildren | void</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data &amp;&amp; data.__ob__) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">      <span class="string">'Always create fresh vnode data objects in each render!'</span>,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> emptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// tag 为字符串</span></span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    <span class="keyword">const</span> ns = config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      <span class="comment">// 内置的节点直接创建一个普通的 vnode</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, normalizeChildren(children, ns),</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, ns, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((Ctor = resolveAsset(context.$options, <span class="string">'components'</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// 如果是已经注册的组件名，通过 createComponent 创建一个组件类型 vnode</span></span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      <span class="keyword">return</span> createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      <span class="comment">// 否则创建一个未知类型标签的 vnode</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, normalizeChildren(children, ns),</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, ns, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// tag 为 Component 类型 调用 createComponent，创建一个组件类型的 vnode</span></span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    <span class="keyword">return</span> createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createElement</code> 实际调用 <code>_createElement</code> 方法，传入 4 个参数，<code>context</code> 表示 vnode 的上下文环境，是 <code>Component</code> 类型；<code>tag</code> 表示标签，可以使一个字符串也可以是一个 <code>Component</code>; <code>data</code> 表示 vnode 的数据，是一个 <code>VNodeData</code> 类型；<code>children</code> 表示当前 vnode 子节点，vnode 元素的数组</p>
<p><code>_createElement</code> 根据 <code>tag</code> 不同类型做判断，如果是 <code>string</code> 类型，则接着判断如果是内置的一些节点，则 <code>new Vnode()</code> 直接创建一个普通 vnode，如果是为已注册的组件名，则通过 <code>createComponent</code> 创建一个组件类型的 vnode，否则创建一个未知的标签的 vnode。 如果是 <code>tag</code> 一个 <code>Component</code> 类型，则直接调用 <code>createComponent</code> 创建一个组件类型的 vnode 节点</p>
<p>注意 vnode 的子节点也应该是 vnode 类型，因此 <code>_createElement</code> 接受的第三个参数 children 也要规范为 vnode 类型，需要调用 <code>normalizeChildren</code> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/helpers/normalzie-children.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeChildren</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  ns: string | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  nestedIndex: number | void</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPrimitive(children)) &#123;</span><br><span class="line">    <span class="comment">// render 函数 children 只有一个节点，如果是基础类型，调用 createTextVNode 创建单个简单的文本节点</span></span><br><span class="line">    <span class="keyword">return</span> [createTextVNode(children)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="comment">// 遍历 children，获得单个节点 c，对 c 的类型进行判断</span></span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> c = children[i]</span><br><span class="line">      <span class="keyword">const</span> last = res[res.length - <span class="number">1</span>]</span><br><span class="line">      <span class="comment">//  nested</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(c)) &#123;</span><br><span class="line">        <span class="comment">// c 为数组，递归调用 normalizeChildren，并 push 进入 结果数组</span></span><br><span class="line">        res.push.apply(res, normalizeChildren(c, ns, i))</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(c)) &#123;</span><br><span class="line">        <span class="comment">// c 是基础类型，调用 createTextNode 转为 vnode 类型，并 push 进入 结果数组</span></span><br><span class="line">        <span class="keyword">if</span> (last &amp;&amp; last.text) &#123;</span><br><span class="line">          last.text += <span class="built_in">String</span>(c)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== <span class="string">''</span>) &#123;</span><br><span class="line">          <span class="comment">// convert primitive to vnode</span></span><br><span class="line">          res.push(createTextVNode(c))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">        <span class="comment">// 已经是 vnode 类型，如果 children 存在嵌套，会根据 nestedIndex 去更新它的 key</span></span><br><span class="line">        <span class="keyword">if</span> (c.text &amp;&amp; last &amp;&amp; last.text) &#123;</span><br><span class="line">          <span class="comment">// 对连续的两个 text 节点会合并为一个 text 节点</span></span><br><span class="line">          last.text += c.text</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// inherit parent namespace</span></span><br><span class="line">          <span class="keyword">if</span> (ns) &#123;</span><br><span class="line">            applyNS(c, ns)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// default key for nested array children (likely generated by v-for)</span></span><br><span class="line">          <span class="keyword">if</span> (c.tag &amp;&amp; c.key == <span class="literal">null</span> &amp;&amp; nestedIndex != <span class="literal">null</span>) &#123;</span><br><span class="line">            c.key = <span class="string">`__vlist_<span class="subst">$&#123;nestedIndex&#125;</span>_<span class="subst">$&#123;i&#125;</span>__`</span></span><br><span class="line">          &#125;</span><br><span class="line">          res.push(c)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>normalizeChilren</code> 方法的调用场景有 2 种，一种是用户自定义 <code>render</code> 函数，当 <code>children</code> 只有一个节点，用户可以写成基础类型来创建单个简单的文本节点，这种情况下调用 <code>createTextVNode</code> 创建一个文本节点的 vnode；另一个场景是当编译 <code>slot</code> <code>v-for</code> 产生嵌套数组的时候</p>
<p><code>normalizeChilren</code> 的主要逻辑是遍历 <code>children</code>, 获得单个节点 <code>c</code> 并判断它的类型，如果 <code>c</code> 是一个数组，递归调用 <code>normalizeChildren</code>，并 push 进入 结果数组; <code>c</code> 是基础类型，调用 <code>createTextNode</code> 转为 vnode 类型，并 push 进入 结果数组; <code>c</code> 已经是 vnode 类型，如果 <code>children</code> 存在嵌套，会根据 nestedIndex 去更新它的 key, 同时对连续的两个 <code>text</code> 节点会合并为一个 text 节点</p>
<h3 id="update-首次渲染"><a href="#update-首次渲染" class="headerlink" title="update 首次渲染"></a>update 首次渲染</h3><p><code>vm._update</code> 被调用的时机有 2 个，一个是首次渲染，另一个是数据更新的时候。先看首次渲染</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">    activeInstance = vm</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// preVnode 不存在说明首次渲染</span></span><br><span class="line">      <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">      <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">      <span class="comment">// vm.$el 为真实 dom，vnode 创建一个新的 dom 替换 vm.$el</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 数据更新</span></span><br><span class="line">      <span class="comment">// 参数都是 vnode</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    activeInstance = prevActiveInstance</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>vm._update()</code> 中关键的是 <code>vm.__patche__()</code> 方法，也是虚拟 dom 中最核心的方法，主要是完成 prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点 patch，最后生成新的真实 dom 节点并完成视图的更新工作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.__patch__ = config._isServer ? noop : patch</span><br><span class="line"></span><br><span class="line"><span class="comment">// platforms/web/runtime/patch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">'core/vdom/patch'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>
<p><code>vm.__patch__()</code> 最终是调用 <code>src/core/vdom/patch.js</code> 中的 <code>createPatchFunction</code> 方法。<code>createPatchFunction</code> 方法内部定义了一系列的辅助方法，最终返回一个 <code>patch</code> 方法，该方法赋值给 <code>vm._update</code> 调用的 <code>vm.__patch__</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> hooks = [<span class="string">'create'</span>, <span class="string">'update'</span>, <span class="string">'postpatch'</span>, <span class="string">'remove'</span>, <span class="string">'destroy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="keyword">const</span> cbs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">    cbs[hooks[i]] = []</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (modules[j][hooks[i]] !== <span class="literal">undefined</span>) cbs[hooks[i]].push(modules[j][hooks[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> elm, parent</span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line">    <span class="comment">// 首次渲染 oldVnode 为 vm.$el 是真实 dom</span></span><br><span class="line">    <span class="keyword">if</span> (!oldVnode) &#123;</span><br><span class="line">      <span class="comment">// empty mount, create new root element</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">          <span class="comment">// mounting to a real element</span></span><br><span class="line">          <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">          <span class="comment">// a successful hydration.</span></span><br><span class="line">          <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(<span class="string">'server-rendered'</span>)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(<span class="string">'server-rendered'</span>)</span><br><span class="line">            hydrating = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hydrating) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">              <span class="keyword">return</span> oldVnode</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">                <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">                <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">                <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">                <span class="string">'full client-side render.'</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">          <span class="comment">// create an empty node and replace it</span></span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">        elm = oldVnode.elm</span><br><span class="line">        parent = nodeOps.parentNode(elm)</span><br><span class="line"></span><br><span class="line">        createElm(vnode, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// component root element replaced.</span></span><br><span class="line">        <span class="comment">// update parent placeholder node element.</span></span><br><span class="line">        <span class="keyword">if</span> (vnode.parent) &#123;</span><br><span class="line">          vnode.parent.elm = vnode.elm</span><br><span class="line">          <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">              cbs.create[i](emptyNode, vnode.parent)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm))</span><br><span class="line">          removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="过程分析-2"><a href="#过程分析-2" class="headerlink" title="过程分析"></a>过程分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        id: <span class="string">'app'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, <span class="keyword">this</span>.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于上面的例子，<code>vm._update</code> 方法会执行首次渲染流程 <code>vm.$el = vm.__patch__(vm.$el, vnode, hydrating)</code>, 这里 <code>vm.$el</code> 为 index.html 模板里的 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 的 dom 对象，<code>vnode</code> 为调用 <code>render</code> 函数的返回值，<code>hydrating</code> 在非服务端渲染情况下为 false</p>
<p>进入 <code>patch</code> 函数，重点分析一个关键步骤</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line"><span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">  patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 首次渲染 oldVnode 一般为一个 dom container，是真实 dom</span></span><br><span class="line">  <span class="comment">// isRealElement 为 true</span></span><br><span class="line">  <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">    <span class="comment">// mounting to a real element</span></span><br><span class="line">    <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">    <span class="comment">// a successful hydration.</span></span><br><span class="line">    <span class="comment">// 服务端渲染逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(<span class="string">'server-rendered'</span>)) &#123;</span><br><span class="line">      oldVnode.removeAttribute(<span class="string">'server-rendered'</span>)</span><br><span class="line">      hydrating = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hydrating) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">        invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVnode</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">          <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">          <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">          <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">          <span class="string">'full client-side render.'</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">    <span class="comment">// create an empty node and replace it</span></span><br><span class="line">    <span class="comment">// 不是服务端渲染，首次渲染 oldVnode 一般为一个 dom container，是真实 dom, 这里就是将 oldVnode 转为 vnode</span></span><br><span class="line">    <span class="comment">// 原先 oldVNode 指向的 dom 作为 vnode 的 elm 属性值</span></span><br><span class="line">    oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    function emptyNodeAt (elm) &#123;</span></span><br><span class="line"><span class="comment">      return new VNode(nodeOps.tagName(elm).toLowerCase(), &#123;&#125;, [], undefined, elm)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  elm = oldVnode.elm <span class="comment">// 将原先 oldVnode 的 elm 值也就是真实 dom 赋给变量 elm</span></span><br><span class="line">  parent = nodeOps.parentNode(elm) <span class="comment">// 首次渲染，parent 一般是 body</span></span><br><span class="line"></span><br><span class="line">  createElm(vnode, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// component root element replaced.</span></span><br><span class="line">  <span class="comment">// update parent placeholder node element.</span></span><br><span class="line">  <span class="comment">// 新 vnode 去掉符父占位符元素</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.parent) &#123;</span><br><span class="line">    vnode.parent.elm = vnode.elm</span><br><span class="line">    <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">        cbs.create[i](emptyNode, vnode.parent)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 插入到它的父节点中，原生 dom 操作</span></span><br><span class="line">    nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm))</span><br><span class="line">    <span class="comment">// 删除 oldVnode （vnode 已经生成 dom 插入文档，要把 oldVnode 删除）</span></span><br><span class="line">    removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    function removeVnodes (parentElm, vnodes, startIdx, endIdx) &#123;</span></span><br><span class="line"><span class="comment">      for (; startIdx &lt;= endIdx; ++startIdx) &#123;</span></span><br><span class="line"><span class="comment">        const ch = vnodes[startIdx]</span></span><br><span class="line"><span class="comment">        if (isDef(ch)) &#123;</span></span><br><span class="line"><span class="comment">          if (isDef(ch.tag)) &#123;</span></span><br><span class="line"><span class="comment">            removeAndInvokeRemoveHook(ch)</span></span><br><span class="line"><span class="comment">            invokeDestroyHook(ch)</span></span><br><span class="line"><span class="comment">          &#125; else &#123; // Text node</span></span><br><span class="line"><span class="comment">            nodeOps.removeChild(parentElm, ch.elm)</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">    invokeDestroyHook(oldVnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的 <code>oldVnode</code> 为一个 dom container，因此 <code>isRealElement</code> 为 true，然后通过 <code>oldVnode = emptyNodeAt(oldVnode)</code> 将 <code>oldVnode</code> 转为 vnode 对象，再调用 <code>createElm</code> 方法</p>
<p><code>createElm</code> 方法是<strong>通过虚拟节点创建真实的 dom</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params">vnode, insertedVnodeQueue, nested</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    vnode.isRootInsert = !nested</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.init)) i(vnode)</span><br><span class="line">      <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">      <span class="comment">// it should've created a child instance and mounted it. the child</span></span><br><span class="line">      <span class="comment">// component also has set the placeholder vnode's elm.</span></span><br><span class="line">      <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(i = vnode.child)) &#123;</span><br><span class="line">        initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">        <span class="keyword">return</span> vnode.elm</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> children = vnode.children</span><br><span class="line">    <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">    <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">      <span class="comment">// vnode tag 是否存在并进行合法性检查</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          !vnode.ns &amp;&amp;</span><br><span class="line">          !(config.ignoredElements &amp;&amp; config.ignoredElements.indexOf(tag) &gt; <span class="number">-1</span>) &amp;&amp;</span><br><span class="line">          config.isUnknownElement(tag)</span><br><span class="line">        ) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'Unknown custom element: &lt;'</span> + tag + <span class="string">'&gt; - did you '</span> +</span><br><span class="line">            <span class="string">'register the component correctly? For recursive components, '</span> +</span><br><span class="line">            <span class="string">'make sure to provide the "name" option.'</span>,</span><br><span class="line">            vnode.context</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用平台 dom 操作创建一个占位符元素</span></span><br><span class="line">      vnode.elm = vnode.ns</span><br><span class="line">        ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">        : nodeOps.createElement(tag)</span><br><span class="line">      setScope(vnode)</span><br><span class="line">      <span class="comment">// 调用 createChildren 创建子元素，并插入到对应父元素中</span></span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        <span class="comment">// 执行所有 create 钩子并把 vnode push 到 insertedVnodeQueue</span></span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vnode.isComment) &#123;</span><br><span class="line">      <span class="comment">// vnode 不含 tag，注释 创建注释节点</span></span><br><span class="line">      vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则创建文本节点</span></span><br><span class="line">      vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>createElm</code> 主要逻辑是先判断 vnode 是否包含 <code>tag</code> 并做合法性检查，如果包含 <code>tag</code> 之后调用平台 dom 操作创建一个占位符元素，接着调用 <code>createChildren</code> 方法创建子元素</p>
<p><code>createChildren</code> 方法遍历子虚拟节点，递归调用 <code>createElm</code>， vnode.elm 作为父容器的 dom 节点占位符传入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历子虚拟节点，递归调用 createElm， vnode.elm 作为父容器的 dom 节点占位符传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildren</span> (<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, <span class="literal">true</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(vnode.text)) &#123;</span><br><span class="line">    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 <code>createElm</code>, 接着执行 <code>invokeCreateHooks</code>, 执行所有 create 钩子并把 vnode push 到 <code>insertedVnodeQueue</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">    cbs.create[i](emptyNode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  i = vnode.data.hook <span class="comment">// Reuse variable</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i.create) i.create(emptyNode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (i.insert) insertedVnodeQueue.push(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 <code>patch</code> 方法，最后把 dom 插入到它的父节点中并删除 <code>oldVnode</code>， 其实就是调用原生 dom api 进行 dom 操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component root element replaced.</span></span><br><span class="line"><span class="comment">// update parent placeholder node element.</span></span><br><span class="line"><span class="keyword">if</span> (vnode.parent) &#123;</span><br><span class="line">  vnode.parent.elm = vnode.elm</span><br><span class="line">  <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">      cbs.create[i](emptyNode, vnode.parent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 插入到它的父节点中</span></span><br><span class="line">  nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm))</span><br><span class="line">  <span class="comment">// 删除旧 oldVnode</span></span><br><span class="line">  removeVnodes(parent, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">  invokeDestroyHook(oldVnode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createPatchFunction 方法 中 定义的 removeVnodes</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">parentElm, vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">    <span class="keyword">const</span> ch = vnodes[startIdx]</span><br><span class="line">    <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(ch.tag)) &#123;</span><br><span class="line">        removeAndInvokeRemoveHook(ch)</span><br><span class="line">        invokeDestroyHook(ch)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// Text node</span></span><br><span class="line">        nodeOps.removeChild(parentElm, ch.elm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vue 封装的 dom 辅助操作方法在<code>src/platforms/web/runtime/node-ops.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/platforms/web/runtime/node-ops.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">appendChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</span><br><span class="line">  node.appendChild(child)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parentNode</span> (<span class="params">node: Node</span>): ?<span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.parentNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，<code>patch</code> 方法的首次渲染就是调用 <code>createEle</code> 方法，这里传入的 <code>parentElm</code> 是 <code>oldVnode.elm</code> 的父元素，例子中为 id 为 #app 的 div 的父元素，也就是 body，实际就是递归创建一个完整的 dom 树并插入到 body 上，并删除 <code>oldVnode</code></p>
<h4 id="update-首次渲染总结"><a href="#update-首次渲染总结" class="headerlink" title="update 首次渲染总结"></a>update 首次渲染总结</h4><ul>
<li><code>vm.$el</code> (真实 dom) 作为 <code>oldVnode</code> 用来创建一个 vnode 并替换 <code>oldVnode</code> (此时 <code>oldVnode</code> 已经不是 dom 而是 vnode)，之前 <code>vm.$el</code> 赋值给 <code>oldVnode</code> 的 elm 属性</li>
<li>调用 <code>createElm</code> 对 <code>vnode</code> 创建 dom 元素</li>
<li>遇到 <code>vnode</code> 的 <code>children</code>，调用 <code>createChilden</code>, 遍历子虚拟节点，递归调用 <code>createElm</code> 生成 dom 并插入到其对应父节点中</li>
<li>最后将 <code>vnode</code> 生成的 dom 插入到它的父元素中，并删除 <code>oldVnode</code></li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-15/88660125.jpg" alt=""></p>
<h3 id="update-组件更新"><a href="#update-组件更新" class="headerlink" title="update 组件更新"></a>update 组件更新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">     <span class="comment">// 首次渲染</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 数据更新</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update</code> 方法组件更新时仍然会调用 <code>patch</code> 方法</p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vdom/patch.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 数据更新时候 oldVnode vnode 都是 vnode 类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> elm, parent</span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!oldVnode) &#123;</span><br><span class="line">      <span class="comment">// empty mount, create new root element</span></span><br><span class="line">      <span class="comment">// oldVnode 不存在，创建一个真实 dom</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 标记旧的 VNode 是否有 nodeType</span></span><br><span class="line">      <span class="comment">// 数据更新是 oldVnode 为 vnode 类型，因此 isRealElement 为 false</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 认为是同一个节点（只是局部更新）就对 oldVnode 和 vnode 进行 diff，并对 oldVnode 打 patch</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 不是同一节点，逻辑基本和首次渲染一样，直接 vnode 来创建真实 dom，插入到父节点中，删除 oldVnode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 insert 钩子</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和首次渲染不同，<code>oldVnode</code> 不为空，并且和 <code>vnode</code> 都是 <code>VNode</code> 类型</p>
<blockquote>
<p>判断新旧 <code>vnode</code> 是否只是进行局部更新的同一个节点是通过 <code>sameVnode()</code> 方法， <strong>只有这 2 个 vnode 的基本属性相同才会认为这 2 个 vnode 只是局部更新，才会进行 diff。如果 2 个 vnode 的基本属性不一致会直接跳过 diff 过程，根据 vnode 新建一个真实 dom，插入到父节点中, 删除 oldVnode</strong></p>
</blockquote>
<p>如 <code>p</code> 和 <code>div</code> 会认为是不同的结构而不去 diff</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/instance/vdom/patch.js</span></span><br><span class="line"><span class="comment">// 判断两个 vnode 的 key tag isComment 相同，data 存在</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">vnode1, vnode2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    vnode1.key === vnode2.key &amp;&amp;</span><br><span class="line">    vnode1.tag === vnode2.tag &amp;&amp;</span><br><span class="line">    vnode1.isComment === vnode2.isComment &amp;&amp;</span><br><span class="line">    !vnode1.data === !vnode2.data</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>patch</code> 过程总结如下：</p>
<ul>
<li>如果 <code>oldVnode</code> 不存在，<code>createEle(vnode)</code> 为 vnode 直接创建真实 dom</li>
<li>否则利用 <code>sameVnode()</code> 判断新旧 vnode 是否是同一个节点, <strong>不是同一个节点（不是局部更新，没必要进一步 diff），vnode 直接创建真实 dom，插入到父节点中，删除 oldVnode</strong></li>
<li>否则新旧 vnode 值得比较，调用 <code>patchVnode()</code></li>
</ul>
</blockquote>
<h4 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> hasData = isDef(i = vnode.data)</span><br><span class="line">  <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm <span class="comment">// 新旧 vnode 只是局部更新，指向同一个真实 dom</span></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">  <span class="comment">// 如果 vnode 不是文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 如果 oldVnode 和 vnode 的 children 属性都存在</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// oldCh 和 ch 不相同，updateCihldren, 对子节点进行 diff</span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 如果 vnode 有子节点，oldVnode 没有子节点，如果 oldVnode 是文本几点先将节点文本清除</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      <span class="comment">// 然后将 vnode 的 children 添加进去</span></span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 有子节点，vnode 没有子节点，删除 elm 下的 oldChildren</span></span><br><span class="line">      removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// oldVnode 是文本节点，就清空节点文本</span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 如果 vnode 是文本节点并且新旧文本不同，直接替换文本内容</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/platforms/web/runtime/node-ops.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setTextContent</span> (<span class="params">node: Node, text: string</span>) </span>&#123;</span><br><span class="line">  node.textContent = text</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">parentElm, vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">    <span class="keyword">const</span> ch = vnodes[startIdx]</span><br><span class="line">    <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(ch.tag)) &#123;</span><br><span class="line">        removeAndInvokeRemoveHook(ch)</span><br><span class="line">        invokeDestroyHook(ch)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// Text node</span></span><br><span class="line">        nodeOps.removeChild(parentElm, ch.elm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVnodes</span> (<span class="params">parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">    nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>patchVnode</code> 方法作用就是将新 <code>vnode</code> patch 到 <code>oldVnode</code> 上</p>
<blockquote>
<p><code>patchVnode</code> 中 diff 过程有几种情况，<code>oldCh</code> 为 <code>oldVnode</code> 的子节点， <code>ch</code> 为 <code>vnode</code> 的子节点：</p>
<ul>
<li>首先进行文本节点判断，如果 <code>oldVnode.text !== vnode.text</code>, 说明 <code>vnode</code> 是文本节点并且新旧文本不同，直接进行文本替换</li>
<li>在 <code>vnode</code> 不是文本节点的情况下，进入子节点 diff</li>
<li>当 <code>oldCh</code> 和 <code>ch</code> 都存在并且不相同的情况下，调用 <code>updateChildren()</code> 对子节点进行 diff</li>
<li>如果只有 <code>ch</code> 存在，说明旧节点不再需要。如果 <code>oldVnode</code> 是文本节点先清空 文本，再调用 <code>addVnodes()</code> 将 <code>ch</code> 添加到 elm 中</li>
<li>如果只有 <code>oldCh</code> 存在，表示更新的是空节点，则调用 <code>removeVnodes</code> 删除 elm 真实节点下 <code>oldCh</code> 子节点</li>
<li>如果 <code>oldVnode</code> 是文本节点，就清空文本内容</li>
</ul>
</blockquote>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren()"></a>updateChildren()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为 oldCh 和 newCh 分别建立索引，作为之后遍历的依据</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, before</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transitions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到 oldCh 或 newCh 被遍历完跳出循环</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// oldStartVnode 被移除，oldStartIdx 指向下一个节点</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// oldEndVnode 被移除，oldEndIdx 指向上一个节点</span></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 插到老的结束节点后面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 插入到老的开始节点前面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果上述条件都不满足，则开始比较 key 值，首先建立 key 和 index 索引的对应关系</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 如果 idxInOld 不存在</span></span><br><span class="line">      <span class="comment">// 1. newStartVnode 上存在这个 key，但是 oldKeyToIdx 中不存在</span></span><br><span class="line">      <span class="comment">// 2. newStartVnode 上没有设置 key 属性</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 创建新的 dom 节点</span></span><br><span class="line">        <span class="comment">// 插入到 oldStartVnode.elm 前面</span></span><br><span class="line">        <span class="comment">// 参见 creatElm() 方法</span></span><br><span class="line">        nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !elmToMove) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'It seems there are duplicate keys that is causing an update error. '</span> +</span><br><span class="line">            <span class="string">'Make sure each v-for item has a unique key.'</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (elmToMove.tag !== newStartVnode.tag) &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">// 创建新的 dom 节点</span></span><br><span class="line">          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          <span class="comment">// 移动 node 节点</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果最后遍历的 oldStartIdx 大于 oldEndIdx</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123; <span class="comment">// 如果是 oldVnode 先被遍历完</span></span><br><span class="line">    before = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    <span class="comment">// 添加 newVnode 中剩余节点到 parentElm 中</span></span><br><span class="line">    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123; <span class="comment">// 如果是 newVnode 新被遍历完，则删除 oldVnode 中所有的节点</span></span><br><span class="line">    <span class="comment">// 删除剩余节点</span></span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始遍历 diff 前，给 <code>oldCh</code> 和 <code>ch</code> 分别分配一个 <code>startIndex</code> 和 <code>endIndex</code> 作为遍历索引，当 <code>oldCh</code> 和 <code>ch</code> 遍历完成（遍历完成的条件是 <code>oldCh</code> 或 <code>ch</code> 的 <code>startIndex &gt;= endIndex</code>）</p>
<p>先看下节点属性不带 key 的情况：</p>
<ul>
<li>从第一个节点开始比较，<code>oldCh</code> 和 <code>ch</code> 的开始节点或结束节点都不存在 <code>sameVnode</code>，第一个 diff 后，<code>ch</code> 的 <code>startVnode</code> 被添加到 <code>oldStartVnode</code> 前面， <code>newStartIndex</code> 后移一位</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-16/83987055.jpg" alt=""></p>
<ul>
<li>第二轮 diff，满足 <code>sameVnode(oldStartVnode, newStartVnode)</code>, 对这两个 vnode 进行 <code>patchVnode</code>, 最后将 patch 打到 <code>oldStartVnode</code>，同时 <code>oldStartIndex</code> <code>newStartIndex</code> 都后移一位</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-16/5191444.jpg" alt=""></p>
<ul>
<li>第三轮 diff，满足 <code>sameVnode(oldEndVnode, newStartVnode)</code>, 对这两个 vnode 进行 <code>patchVnode</code>, 最后将 patch 打到 <code>oldEndVnode</code>，并完成 <code>oldEndVnode</code> 的移位操作，同时 <code>oldEndIndex</code> 前移一位 <code>newStartIndex</code> 后移一位</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-16/59141550.jpg" alt=""></p>
<ul>
<li>第四轮 diff 过程同第三轮 diff</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-16/19380189.jpg" alt=""></p>
<ul>
<li>第五轮 diff 过程同第一轮 diff</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-16/99938328.jpg" alt=""></p>
<ul>
<li>遍历结束此时 <code>newStartIndex &gt; newEndIndex</code>，此时 <code>oldCh</code> 存在多余节点，需要进行删除</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-16/31595673.jpg" alt=""></p>
<blockquote>
<p><strong>在 vnode 节点属性不带 key 的情况下，每一轮 diff 都是 <strong>开始</strong> 和 <strong>结束</strong> 节点进行比较，直到 <code>oldCh</code> 或 <code>ch</code> 被遍历完.</strong> 当 vnode 带有 key 属性，遍历 diff 过程中，当 <code>起始点</code> <code>结束点</code>的 搜寻以及 diff 出现无法匹配的情况，会用 key 作为唯一标识进行 diff，提高 diff 效率</p>
</blockquote>
<p>带有 key 的 vnode 的 diff 过程</p>
<ul>
<li>注意第一轮 diff 后 <code>oldCh</code> 上的 B 节点被删除，但是 <code>ch</code> 上 B 节点的 <code>elm</code> 属性保持对 <code>oldCh</code> 上 B 节点的 <code>elm</code> 引用</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-16/17332475.jpg" alt=""><br><img src="http://ony85apla.bkt.clouddn.com/18-6-16/40488653.jpg" alt=""><br><img src="http://ony85apla.bkt.clouddn.com/18-6-16/71819335.jpg" alt=""><br><img src="http://ony85apla.bkt.clouddn.com/18-6-16/27358504.jpg" alt=""><br><img src="http://ony85apla.bkt.clouddn.com/18-6-16/25299407.jpg" alt=""></p>
<h4 id="update-数据更新过程总结"><a href="#update-数据更新过程总结" class="headerlink" title="update 数据更新过程总结"></a>update 数据更新过程总结</h4><p>组件更新的过程核心就是新旧 vnode diff，对新旧节点相同和不同的情况分别坐不同处理；新旧节点不同的更新流程是创建新节点-》更新父占位符节点-》删除旧节点；新旧节点相同（只是局部更新）的更新流程是去获取他们的 children，根据不同情况做不同的处理。最复杂的情况是新旧节点相同并且都存在子节点，需要执行 <code>updateChildren</code></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/vue/" rel="tag"># vue</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/12/vue 2.0 生命周期/" rel="next" title="vue 2.0 生命周期">
                <i class="fa fa-chevron-left"></i> vue 2.0 生命周期
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/17/vue-cli webpack 配置/" rel="prev" title="vue-cli webpack 配置">
                vue-cli webpack 配置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars0.githubusercontent.com/u/8380737?s=460&v=4"
                alt="jhgrrewq" />
            
              <p class="site-author-name" itemprop="name">jhgrrewq</p>
              <p class="site-description motion-element" itemprop="description">爱好电影，更爱女神阿佳妮；爱网球，更爱罗杰费德勒。网易云音乐深度用户</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">101</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jhgrrewq" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#代码结构"><span class="nav-number">1.</span> <span class="nav-text">代码结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-构造函数"><span class="nav-number">2.</span> <span class="nav-text">Vue 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initMixin"><span class="nav-number">2.1.</span> <span class="nav-text">initMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stateMixin"><span class="nav-number">2.2.</span> <span class="nav-text">stateMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eventsMixin"><span class="nav-number">2.3.</span> <span class="nav-text">eventsMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lifecycleMixin"><span class="nav-number">2.4.</span> <span class="nav-text">lifecycleMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#renderMixin"><span class="nav-number">2.5.</span> <span class="nav-text">renderMixin()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-vue-实例"><span class="nav-number">3.</span> <span class="nav-text">创建 vue 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initLifecycle"><span class="nav-number">3.1.</span> <span class="nav-text">initLifecycle()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initEvents"><span class="nav-number">3.2.</span> <span class="nav-text">initEvents()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initRender"><span class="nav-number">3.3.</span> <span class="nav-text">initRender()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initState"><span class="nav-number">3.4.</span> <span class="nav-text">initState()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应式原理"><span class="nav-number">4.</span> <span class="nav-text">响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#响应式对象"><span class="nav-number">4.1.</span> <span class="nav-text">响应式对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#initData"><span class="nav-number">4.1.1.</span> <span class="nav-text">initData()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observer-类"><span class="nav-number">4.1.2.</span> <span class="nav-text">Observer 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defineReactive"><span class="nav-number">4.1.3.</span> <span class="nav-text">defineReactive</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖收集"><span class="nav-number">4.2.</span> <span class="nav-text">依赖收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getter"><span class="nav-number">4.2.1.</span> <span class="nav-text">getter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dep"><span class="nav-number">4.2.2.</span> <span class="nav-text">Dep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watcher"><span class="nav-number">4.2.3.</span> <span class="nav-text">watcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过程分析"><span class="nav-number">4.2.4.</span> <span class="nav-text">过程分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派发更新"><span class="nav-number">4.3.</span> <span class="nav-text">派发更新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setter"><span class="nav-number">4.3.1.</span> <span class="nav-text">setter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过程分析-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">过程分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nextTick"><span class="nav-number">4.4.</span> <span class="nav-text">nextTick</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JS-运行机制"><span class="nav-number">4.4.1.</span> <span class="nav-text">JS 运行机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue-中-nextTick"><span class="nav-number">4.4.2.</span> <span class="nav-text">Vue 中 nextTick</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-中检测变化的问题"><span class="nav-number">4.5.</span> <span class="nav-text">vue 中检测变化的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#响应式对象新添加的属性"><span class="nav-number">4.5.1.</span> <span class="nav-text">响应式对象新添加的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">4.5.2.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#computed"><span class="nav-number">4.6.</span> <span class="nav-text">computed</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板编译"><span class="nav-number">5.</span> <span class="nav-text">模板编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mount"><span class="nav-number">5.1.</span> <span class="nav-text">$mount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译-render-函数"><span class="nav-number">5.2.</span> <span class="nav-text">编译 render 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#render-函数概念"><span class="nav-number">5.2.1.</span> <span class="nav-text">render 函数概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译-render-函数过程"><span class="nav-number">5.2.2.</span> <span class="nav-text">编译 render 函数过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟-dom"><span class="nav-number">6.</span> <span class="nav-text">虚拟 dom</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vnode"><span class="nav-number">6.1.</span> <span class="nav-text">vnode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createElement"><span class="nav-number">6.2.</span> <span class="nav-text">createElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update-首次渲染"><span class="nav-number">6.3.</span> <span class="nav-text">update 首次渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过程分析-2"><span class="nav-number">6.3.1.</span> <span class="nav-text">过程分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update-首次渲染总结"><span class="nav-number">6.3.2.</span> <span class="nav-text">update 首次渲染总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update-组件更新"><span class="nav-number">6.4.</span> <span class="nav-text">update 组件更新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#patch"><span class="nav-number">6.4.1.</span> <span class="nav-text">patch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#patchVnode"><span class="nav-number">6.4.2.</span> <span class="nav-text">patchVnode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#updateChildren"><span class="nav-number">6.5.</span> <span class="nav-text">updateChildren()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#update-数据更新过程总结"><span class="nav-number">6.5.1.</span> <span class="nav-text">update 数据更新过程总结</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jhgrrewq</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  


</body>
</html>
