<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="vue," />










<meta name="description" content="参考: Vue全家桶实现原理简要梳理、Vue 2.0 的 virtual-dom 实现简析、深入Vue2.0底层思想–模板渲染、Vue.js 技术揭秘  本文 vue@2.0.0 代码结构12345678910111213141516171819202122├── compiler/               // 解析 template，生成 render 函数和 ast│   ├── co">
<meta name="keywords" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="vue 2.0 源码学习">
<meta property="og:url" content="http://jhgrrewq.github.io/2018/06/13/vue 2.0 源码学习/index.html">
<meta property="og:site_name" content="jhgrrewq 前端小站">
<meta property="og:description" content="参考: Vue全家桶实现原理简要梳理、Vue 2.0 的 virtual-dom 实现简析、深入Vue2.0底层思想–模板渲染、Vue.js 技术揭秘  本文 vue@2.0.0 代码结构12345678910111213141516171819202122├── compiler/               // 解析 template，生成 render 函数和 ast│   ├── co">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-13/93728031.jpg">
<meta property="og:image" content="http://ony85apla.bkt.clouddn.com/18-6-14/25554080.jpg">
<meta property="og:updated_time" content="2018-06-14T08:21:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue 2.0 源码学习">
<meta name="twitter:description" content="参考: Vue全家桶实现原理简要梳理、Vue 2.0 的 virtual-dom 实现简析、深入Vue2.0底层思想–模板渲染、Vue.js 技术揭秘  本文 vue@2.0.0 代码结构12345678910111213141516171819202122├── compiler/               // 解析 template，生成 render 函数和 ast│   ├── co">
<meta name="twitter:image" content="http://ony85apla.bkt.clouddn.com/18-6-13/93728031.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'O0AP0FGXSX',
      apiKey: 'ab7c2224e88a925feeea82c8902add9d',
      indexName: 'jhgrrewq',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jhgrrewq.github.io/2018/06/13/vue 2.0 源码学习/"/>





  <title>vue 2.0 源码学习 | jhgrrewq 前端小站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jhgrrewq 前端小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">置我于死地者 必将赐我以后生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jhgrrewq.github.io/2018/06/13/vue 2.0 源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jhgrrewq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/8380737?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jhgrrewq 前端小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">vue 2.0 源码学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T09:50:56+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>参考: <a href="https://github.com/tsy77/blog/issues/1" target="_blank" rel="noopener">Vue全家桶实现原理简要梳理</a>、<a href="https://github.com/DDFE/DDFE-blog/issues/18" target="_blank" rel="noopener">Vue 2.0 的 virtual-dom 实现简析</a>、<a href="http://developer.51cto.com/art/201707/545802.htm" target="_blank" rel="noopener">深入Vue2.0底层思想–模板渲染</a>、<a href="https://ustbhuangyi.github.io/vue-analysis" target="_blank" rel="noopener">Vue.js 技术揭秘</a></p>
</blockquote>
<p>本文 <a href="mailto:vue@2.0.0" target="_blank" rel="noopener">vue@2.0.0</a></p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── compiler/               <span class="comment">// 解析 template，生成 render 函数和 ast</span></span><br><span class="line">│   ├── codegen/                    <span class="comment">// 根据 ast 生成 render 函数</span></span><br><span class="line">│   ├── directives/                 <span class="comment">// 解析 ast 中指令，生成对应 render 函数</span></span><br><span class="line">│   └── parser/                     <span class="comment">// 正则遍历 template 字符串，通过栈记录元素关系，生成 ast</span></span><br><span class="line">├── core                    <span class="comment">// Vue 实例相关，vue 源码核心</span></span><br><span class="line">│   ├── components/                 <span class="comment">// 通用组件，keep-alive 组件</span></span><br><span class="line">│   ├── global-api/                 <span class="comment">// 注册 Vue 构造函数上的静态方法，如 Vue.install、Vue.set...</span></span><br><span class="line">│   ├── instance/                   <span class="comment">// 注册 Vue.prototype，以及构造函数</span></span><br><span class="line">│   ├── observer/                   <span class="comment">// 数据双向绑定相关，主要有 watcher observer dep</span></span><br><span class="line">│   ├── util/                       <span class="comment">// 工具</span></span><br><span class="line">│   └── vdom/                       <span class="comment">// vnode 相关，包含 createVnode， patchNode 等</span></span><br><span class="line">├── platforms               <span class="comment">// core 基础上扩展</span></span><br><span class="line">│   └── web/                        <span class="comment">// 将 core 中代码包装成 web 平台所需要的方法，如 Vue.prototype.$mount 实际包装了 core 中的 $mount</span></span><br><span class="line">│       ├── compiler/</span><br><span class="line">│       ├── runtime/</span><br><span class="line">│       ├── server/</span><br><span class="line">│       └── util/</span><br><span class="line">├── server/                 <span class="comment">// ssr 相关，执行 Vue 代码，生成 Vue 实例；输出流或字符串，传递给 renderNode，renderNode 通过 vnode 生成各种 HTML 标签</span></span><br><span class="line">├── sfc</span><br><span class="line">│   └── parser.js</span><br><span class="line">└── shared                  <span class="comment">// 上述公共工具</span></span><br><span class="line">    └── util.js</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Vue-构造函数"><a href="#Vue-构造函数" class="headerlink" title="Vue 构造函数"></a>Vue 构造函数</h2><p><code>src/core/instance/index.js</code> 定义了 Vue 构造函数，并且<strong>初始化了一些 Vue.prototype 的方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)        <span class="comment">// Vue.prototype._init()...</span></span><br><span class="line">stateMixin(Vue)       <span class="comment">// Vue.prototype.$data/$set/$delete/$watch...</span></span><br><span class="line">eventsMixin(Vue)      <span class="comment">// Vue.prototype.$on/$once/$off/$emit...</span></span><br><span class="line">lifecycleMixin(Vue)   <span class="comment">// Vue.prototype._update()/_mount()/$destroy()...</span></span><br><span class="line">renderMixin(Vue)      <span class="comment">// Vue.prototype._render()...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<h3 id="initMixin"><a href="#initMixin" class="headerlink" title="initMixin()"></a>initMixin()</h3><p><code>initMixin()</code> 给 Vue.prototype 挂载了一个 <code>_init()</code> 方法，方便之后 vue 实例初始化调用</p>
<blockquote>
<p>Vue 初始化主要就是<strong>合并配置(<code>mergeOptions()</code>）、初始化生命周期 (<code>initLifecycle()</code>)、初始化事件中心(<code>initEvents()</code>)、初始化 data props cumputed watch methods(<code>initState()</code>)、初始化渲染(<code>initRender()</code>)</strong>等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 合并参数</span></span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    initLifecycle(vm) <span class="comment">// 初始化生命周期</span></span><br><span class="line">    initEvents(vm)  <span class="comment">// 初始化事件中心</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>) <span class="comment">// beforeCreate 钩子 数据属性未初始化</span></span><br><span class="line">    initState(vm) <span class="comment">// 初始化 data props computed watch methods</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>) <span class="comment">// created 钩子 数据属性初始化</span></span><br><span class="line">    initRender(vm) <span class="comment">// 初始化渲染</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stateMixin"><a href="#stateMixin" class="headerlink" title="stateMixin()"></a>stateMixin()</h3><p><code>stateMixin()</code> 声明了 <code>Vue.prototype.$data</code>、<code>Vue.prototype.$set</code>、<code>Vue.prototype.$delete</code>、<code>Vue.prototype.$watch</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// flow somehow has problems with directly declared definition object</span></span><br><span class="line">  <span class="comment">// when using Object.defineProperty, so we have to procedurally build up</span></span><br><span class="line">  <span class="comment">// the object here.</span></span><br><span class="line">  <span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">  dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 通过 vm.$data(this.$data) 访问 Vue 实例代理了对其 data 对象属性的访问</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$data'</span>, dataDef)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 vm.$set(this.$set) 设置值，等同于全局 Vue.set</span></span><br><span class="line">  Vue.prototype.$set = set</span><br><span class="line">  <span class="comment">// 通过 vm.$delete(this.$delete) 删除对象的值，如果对象是响应式，确保删除能更新视图，等同于全局 Vue.delete</span></span><br><span class="line">  Vue.prototype.$<span class="keyword">delete</span> = del</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 vm.$watch(cb) / this.$watch(cb) 观察 vue 实例变化的一个表达式或计算属性函数，回调函数得到的参数是新值和旧值</span></span><br><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    cb: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">    options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="eventsMixin"><a href="#eventsMixin" class="headerlink" title="eventsMixin()"></a>eventsMixin()</h3><p><code>eventsMixin()</code> 主要定义了 <code>Vue.prototype.$on</code>、<code>Vue.prototype.$off</code>、<code>Vue.prototype.$once</code>、<code>Vue.prototype.$emit</code>, 原理是利用发布订阅模式，在 <code>Vue._events</code> 中给每一个 event 维护一个订阅队列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/events.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">eventsMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// Vue._events 给每一个 event 维护一个订阅队列，相关回调 push 进入该队列</span></span><br><span class="line">    ;(vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 重新封装一个函数，函数内部先取消该订阅回调，再执行传入的 fn</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 先取消该订阅回调，再执行传入的 fn</span></span><br><span class="line">      vm.$off(event, on)</span><br><span class="line">      fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    on.fn = fn</span><br><span class="line">    vm.$on(event, on)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有参数，清空全部 event 的全部订阅回调（vm._events 设置空对象）</span></span><br><span class="line">    <span class="comment">// 如果没有第二个参数， 对应 event 的订阅队列直接清空（清除所有订阅回调）</span></span><br><span class="line">    <span class="comment">// 如果对应 event 要取消的回调，从 Vue._events 取出该 event 的订阅队列遍历查找后删除</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// all</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// specific event</span></span><br><span class="line">    <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">    <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">      vm._events[event] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// specific handler</span></span><br><span class="line">    <span class="keyword">let</span> cb</span><br><span class="line">    <span class="keyword">let</span> i = cbs.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      cb = cbs[i]</span><br><span class="line">      <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">        cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">    <span class="comment">// 取出 vm._events 对应 event 的订阅回调，并传入参数执行</span></span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">      cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">      <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">        cbs[i].apply(vm, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lifecycleMixin"><a href="#lifecycleMixin" class="headerlink" title="lifecycleMixin()"></a>lifecycleMixin()</h3><p><code>lifecycleMixin()</code> <strong>定义了 Vue 中经常使用的 <code>Vue.prototype.update</code> 方法，每当组件 data 变化或者其他原因需要重新渲染时候，Vue 会调用该方法，对 <code>vnode</code> 进行 diff 和 patch 操作</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    el?: Element | void,</span></span></span><br><span class="line"><span class="function"><span class="params">    hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    vm.$el = el</span><br><span class="line">    <span class="comment">// 即时 vm 实例选项没有 render，$mount 方法调用时候已经 将 template 属性 或 el 属性的 outerHTML 转为 render 函数（在 有 compiler 版本的 vue 库文件下），并将 render 函数 设置为 vm.$options.render 属性值</span></span><br><span class="line">    <span class="comment">// 如果 vue 实例 render 属性不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">      vm.$options.render = emptyVNode</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (vm.$options.template) &#123;</span><br><span class="line">          <span class="comment">// 有 template 属性，说明没能转化为 render 函数，说明使用 运行时版本 vue.js 文件，要么预先转换 template ，要么使用 独立构建版本的 vue.js 文件</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">            <span class="string">'option is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">            <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">    <span class="comment">// 调动 vm._render, 通过 render 函数返回 vnode</span></span><br><span class="line">    <span class="comment">// 首次渲染 和 每次数据属性更新会执行该 watcher 中的回调，执行 vm._update() 对 vnode 进行 diff 和 patch</span></span><br><span class="line">    vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;, noop)</span><br><span class="line">    hydrating = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// root instance, call mounted on self</span></span><br><span class="line">    <span class="comment">// mounted is called for child components in its inserted hook</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$root === vm) &#123;</span><br><span class="line">      vm._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新节点</span></span><br><span class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 如果该组件已经挂载过了则表明这个步骤是更新过程，触发 beforeUpdate 钩子</span></span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el <span class="comment">// 实例挂载后，可以使用 vm.$el 访问挂载元素</span></span><br><span class="line">    <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">    activeInstance = vm</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode <span class="comment">// vm._vnode 存放的是 旧 vnode</span></span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">      <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">      <span class="comment">// 如果不存在 prevVnode 说明是初次挂载，直接将 vnode 创建一个真实的 dom 节点渲染到 vm.$el</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果存在 prevVnode，进行新旧 vnode 对比 diff，并将需要更新的 dom 操作 patch 形式打到 prevVnode 上，完成真实 dom 更新</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    activeInstance = prevActiveInstance</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="comment">// 更新实例对象的 __vue__</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype._updateFromParent = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    propsData: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    listeners: ?Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    parentVnode: VNode,</span></span></span><br><span class="line"><span class="function"><span class="params">    renderChildren: ?VNodeChildren</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> hasChildren = !!(vm.$options._renderChildren || renderChildren)</span><br><span class="line">    vm.$options._parentVnode = parentVnode</span><br><span class="line">    vm.$options._renderChildren = renderChildren</span><br><span class="line">    <span class="comment">// update props</span></span><br><span class="line">    <span class="keyword">if</span> (propsData &amp;&amp; vm.$options.props) &#123;</span><br><span class="line">      observerState.shouldConvert = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        observerState.isSettingProps = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> propKeys = vm.$options._propKeys || []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; propKeys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = propKeys[i]</span><br><span class="line">        vm[key] = validateProp(key, vm.$options.props, propsData, vm)</span><br><span class="line">      &#125;</span><br><span class="line">      observerState.shouldConvert = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        observerState.isSettingProps = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update listeners</span></span><br><span class="line">    <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldListeners = vm.$options._parentListeners</span><br><span class="line">      vm.$options._parentListeners = listeners</span><br><span class="line">      vm._updateListeners(listeners, oldListeners)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// resolve slots + force update if has children</span></span><br><span class="line">    <span class="keyword">if</span> (hasChildren) &#123;</span><br><span class="line">      vm.$slots = resolveSlots(renderChildren, vm._renderContext)</span><br><span class="line">      vm.$forceUpdate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 beforeDestroy 钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeDestroy'</span>)</span><br><span class="line">    <span class="comment">// 标识位</span></span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// remove self from parent</span></span><br><span class="line">    <span class="keyword">const</span> parent = vm.$parent</span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</span><br><span class="line">      remove(parent.$children, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// teardown watchers</span></span><br><span class="line">    <span class="comment">// 该组件中的所有 watcher 会从其所在的 Dep 中释放</span></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = vm._watchers.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      vm._watchers[i].teardown()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove reference from data ob</span></span><br><span class="line">    <span class="comment">// frozen object may not have observer.</span></span><br><span class="line">    <span class="keyword">if</span> (vm._data.__ob__) &#123;</span><br><span class="line">      vm._data.__ob__.vmCount--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// call the last hook...</span></span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 调用 destroyed 钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'destroyed'</span>)</span><br><span class="line">    <span class="comment">// turn off all instance listeners.</span></span><br><span class="line">    <span class="comment">// 移除所有事件监听</span></span><br><span class="line">    vm.$off()</span><br><span class="line">    <span class="comment">// remove __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="renderMixin"><a href="#renderMixin" class="headerlink" title="renderMixin()"></a>renderMixin()</h3><p><code>renderMixin()</code> 定义了 <code>Vue.prototype._render</code> 等方法，<code>_render</code> 方法调用实例化时传入的 <code>render函数</code>（vue 实例）选项中没有 <code>render 函数</code>，会从 <code>template</code> 属性或 <code>el</code> 属性的 outerHTML 编译成 <code>render 函数</code>)，<strong>生成 vnode</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    el?: Element | void,</span></span></span><br><span class="line"><span class="function"><span class="params">    hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 一般数据、组件更新</span></span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;, noop)</span><br><span class="line">    hydrating = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/render.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'../config'</span></span><br><span class="line"><span class="keyword">import</span> VNode, &#123; emptyVNode, cloneVNode, cloneVNodes &#125; <span class="keyword">from</span> <span class="string">'../vdom/vnode'</span></span><br><span class="line"><span class="keyword">import</span> &#123; normalizeChildren &#125; <span class="keyword">from</span> <span class="string">'../vdom/helpers'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  warn, formatComponentName, bind, isObject, toObject,</span><br><span class="line">  nextTick, resolveAsset, _toString, toNumber, looseEqual, looseIndexOf</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createElement &#125; <span class="keyword">from</span> <span class="string">'../vdom/create-element'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm.$vnode = <span class="literal">null</span> <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span></span><br><span class="line">  vm._renderContext = vm.$options._parentVnode &amp;&amp; vm.$options._parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext)</span><br><span class="line">  <span class="comment">// bind the public createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 除了 vm.$createElement, 之后的 vue 版本还提供了 vm._c 方法，两者支持的参数相同，内部都是调用了 createElement 方法，只是一般 vm.$createElement 一般用于用户手写 render 函数，vm._c 是被 vue 内部被模板编译成的 render 函数使用</span></span><br><span class="line">  vm.$createElement = bind(createElement, vm)</span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">    nextTick(fn, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 从 vm.$options.render 拿到 render 函数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      render,</span><br><span class="line">      staticRenderFns,</span><br><span class="line">      _parentVnode</span><br><span class="line">    &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      <span class="comment">// clone slot nodes on re-renders</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vm.$slots) &#123;</span><br><span class="line">        vm.$slots[key] = cloneVNodes(vm.$slots[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (staticRenderFns &amp;&amp; !vm._staticTrees) &#123;</span><br><span class="line">      vm._staticTrees = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 传入 vm.vm.$createElement 执行 render 函数，返回 vnode</span></span><br><span class="line">      <span class="comment">// 一般在 初始化 vue 实例时候写 render 函数 render：h =&gt; h(...) h 就是 vm.$createElement 方法</span></span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        warn(<span class="string">`Error when rendering <span class="subst">$&#123;formatComponentName(vm)&#125;</span>:`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (config.errorHandler) &#123;</span><br><span class="line">        config.errorHandler.call(<span class="literal">null</span>, e, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (config._isServer) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> e &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// return previous vnode to prevent render error causing blank component</span></span><br><span class="line">      vnode = vm._vnode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</span><br><span class="line">          <span class="string">'should return a single root node.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = emptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    <span class="comment">// _render 方法返回 vnode</span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// shorthands used in render functions</span></span><br><span class="line">  <span class="comment">// _h 其实就是 createElement 函数</span></span><br><span class="line">  <span class="comment">// vue 新版本 _c 也是 createElement 函数</span></span><br><span class="line">  Vue.prototype._h = createElement</span><br><span class="line">  <span class="comment">// toString for mustaches</span></span><br><span class="line">  <span class="comment">// _s 转为字符串</span></span><br><span class="line">  Vue.prototype._s = _toString</span><br><span class="line">  <span class="comment">// number conversion</span></span><br><span class="line">  <span class="comment">// _n 转为数字</span></span><br><span class="line">  Vue.prototype._n = toNumber</span><br><span class="line">  <span class="comment">// empty vnode</span></span><br><span class="line">  <span class="comment">// _e 空 vnode</span></span><br><span class="line">  Vue.prototype._e = emptyVNode</span><br><span class="line">  <span class="comment">// loose equal</span></span><br><span class="line">  Vue.prototype._q = looseEqual</span><br><span class="line">  <span class="comment">// loose indexOf</span></span><br><span class="line">  Vue.prototype._i = looseIndexOf</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render static tree by index</span></span><br><span class="line">  <span class="comment">// _m 通过下标渲染静态节点树 // 传入 index 返回对应的 staticRenderFns 函数并执行</span></span><br><span class="line">  Vue.prototype._m = <span class="function"><span class="keyword">function</span> <span class="title">renderStatic</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    index: number,</span></span></span><br><span class="line"><span class="function"><span class="params">    isInFor?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tree = <span class="keyword">this</span>._staticTrees[index]</span><br><span class="line">    <span class="comment">// if has already-rendered static tree and not inside v-for,</span></span><br><span class="line">    <span class="comment">// we can reuse the same tree by doing a shallow clone.</span></span><br><span class="line">    <span class="keyword">if</span> (tree &amp;&amp; !isInFor) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(tree)</span><br><span class="line">        ? cloneVNodes(tree)</span><br><span class="line">        : cloneVNode(tree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// otherwise, render a fresh tree.</span></span><br><span class="line">    tree = <span class="keyword">this</span>._staticTrees[index] = <span class="keyword">this</span>.$options.staticRenderFns[index].call(<span class="keyword">this</span>._renderProxy)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">        tree[i].isStatic = <span class="literal">true</span></span><br><span class="line">        tree[i].key = <span class="string">`__static__<span class="subst">$&#123;index&#125;</span>_<span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tree.isStatic = <span class="literal">true</span></span><br><span class="line">      tree.key = <span class="string">`__static__<span class="subst">$&#123;index&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// render v-for</span></span><br><span class="line">  <span class="comment">// _l 渲染 v-for</span></span><br><span class="line">  Vue.prototype._l = <span class="function"><span class="keyword">function</span> <span class="title">renderList</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    render: (</span>) =&gt; <span class="title">VNode</span></span></span><br><span class="line"><span class="function">  ): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret: ?<span class="built_in">Array</span>&lt;VNode&gt;, i, l, keys, key</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(val)) &#123;</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val.length)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.length; i &lt; l; i++) &#123;</span><br><span class="line">        ret[i] = render(val[i], i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) &#123;</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; val; i++) &#123;</span><br><span class="line">        ret[i] = render(i + <span class="number">1</span>, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(val)) &#123;</span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">      ret = <span class="keyword">new</span> <span class="built_in">Array</span>(keys.length)</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        key = keys[i]</span><br><span class="line">        ret[i] = render(val[key], key, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// renderSlot</span></span><br><span class="line">  <span class="comment">// _t 渲染 slot</span></span><br><span class="line">  Vue.prototype._t = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    fallback: ?Array&lt;VNode&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// apply v-bind object</span></span><br><span class="line">  <span class="comment">// _b 应用 v-bind 对象</span></span><br><span class="line">  Vue.prototype._b = <span class="function"><span class="keyword">function</span> <span class="title">bindProps</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    value: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    asProp?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">VNodeData</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose v-on keyCodes</span></span><br><span class="line">  Vue.prototype._k = <span class="function"><span class="keyword">function</span> <span class="title">getKeyCodes</span> (<span class="params">key: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.keyCodes[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="创建-vue-实例"><a href="#创建-vue-实例" class="headerlink" title="创建 vue 实例"></a>创建 vue 实例</h2><p><img src="http://ony85apla.bkt.clouddn.com/18-6-13/93728031.jpg" alt=""></p>
<p><code>new Vue({})</code> 实际调用了构造函数中的 <code>this._init()</code>, <code>this._init()</code> 就是调用 <code>core/instance/init.js</code> 中定义的 <code>Vue.prototype._init</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    <span class="comment">// 初始化生命周期</span></span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    <span class="comment">// 初始化事件中心</span></span><br><span class="line">    initEvents(vm)</span><br><span class="line">    <span class="comment">// 调用 beforeCreate 钩子函数并触发 beforeCreate 钩子事件</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    <span class="comment">// 初始化 props data methods computed 和 watch</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    <span class="comment">// 调用 created 钩子函数并触发 created 钩子事件</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line">    <span class="comment">// 初始化渲染</span></span><br><span class="line">    initRender(vm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle()"></a>initLifecycle()</h3><p><code>initLifecycle()</code> 主要是将自己 push 到 parent.$children 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="comment">// 初始化生命周期</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line"></span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="comment">// 将 vm 对象存储到 parent 组件中（保证 parent 组件是非抽象组件，如 keep-alive）</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  vm.$root = parent ? parent.$root : vm</span><br><span class="line"></span><br><span class="line">  vm.$children = []</span><br><span class="line">  vm.$refs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm._watcher = <span class="literal">null</span></span><br><span class="line">  vm._inactive = <span class="literal">false</span></span><br><span class="line">  vm._isMounted = <span class="literal">false</span></span><br><span class="line">  vm._isDestroyed = <span class="literal">false</span></span><br><span class="line">  vm._isBeingDestroyed = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents()"></a>initEvents()</h3><p><code>initEvents()</code> 主要初始化 <code>vm._events</code> 事件中心存放事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/events.js</span></span><br><span class="line"><span class="comment">// 初始化事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 vm 上创建 _events 对象用来存放事件以及事件对应的订阅队列</span></span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initRender"><a href="#initRender" class="headerlink" title="initRender()"></a>initRender()</h3><p><code>initRender()</code> 定义了 <code>vm.$createElement</code> 方法，并<strong>执行 <code>vm.$mount</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 render</span></span><br><span class="line"><span class="comment">// src/core/instance/render.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm.$vnode = <span class="literal">null</span> <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span></span><br><span class="line">  vm._renderContext = vm.$options._parentVnode &amp;&amp; vm.$options._parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext)</span><br><span class="line">  <span class="comment">// bind the public createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// 将 createElement 函数绑定到 vm 实例上</span></span><br><span class="line">  vm.$createElement = bind(createElement, vm)</span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p><code>initState()</code> 主要是 <code>initProps, initComputed, initData, initMethods,initWatch</code>，对 props data computed methods watch 等属性进行初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"><span class="comment">// 初始化 props data computed methods watch</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  initProps(vm)</span><br><span class="line">  initData(vm)</span><br><span class="line">  initComputed(vm)</span><br><span class="line">  initMethods(vm)</span><br><span class="line">  initWatch(vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h3><h4 id="initData"><a href="#initData" class="headerlink" title="initData()"></a>initData()</h4><p>以 <code>initData()</code> 为例来理解 Vue 的 响应式原理</p>
<p><code>initData()</code> 对 <code>data</code> 的初始化做了两件事：</p>
<ul>
<li>对定义 <code>data</code> 函数返回对象的遍历，<strong>通过 <code>proxy</code> 方法把每一个值 <code>vm._data.xxx</code> 代理到 <code>vm.xxx</code></strong></li>
<li><strong>调用 <code>observe</code> 方法观测 <code>data</code> 变化，将 <code>data</code> 变成响应式</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 得到 data 数据</span></span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? data.call(vm) <span class="comment">// 组件中 data 属性必须是函数类型</span></span><br><span class="line">    : data || &#123;&#125; <span class="comment">// vue 实例中 data 属性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对对象类型进行严格检查，只有对象是纯 js 对象时返回 true</span></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object.'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="comment">// 遍历 data 对象</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 data 中数据</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="comment">// 保证 data 中的 key 不和 props 中的 key 重复，props 优先，冲突会报 warning</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;keys[i]&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将 data 上面的属性代理到 vm 实例上</span></span><br><span class="line">      proxy(vm, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 对数据进行添加 getter setter，observe 递归对深层对象的遍历，并添加 getter setter</span></span><br><span class="line">  observe(data)</span><br><span class="line">  data.__ob__ &amp;&amp; data.__ob__.vmCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy 方法将 data 上属性代理到 vm 上</span></span><br><span class="line"><span class="comment">// 访问 vm[key], 其实代理访问 vm._data[key]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">vm: Component, key: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是保留字段</span></span><br><span class="line">  <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vm._data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        vm._data[key] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>observe()</code> 中 <code>new Observer()</code>, 最终会对 <code>data</code> 中所有数据调用 <code>defineReactive</code> 变成响应式(包括子对象递归 <code>observe()</code>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    observerState.shouldConvert &amp;&amp;</span><br><span class="line">    !config._isServer &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 核心代码 实例化一个 Observer 对象</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Observer-类"><a href="#Observer-类" class="headerlink" title="Observer 类"></a>Observer 类</h4><p><code>Observer</code> 类用于给对象添加 getter 和 setter，用于依赖收集和派发更新</p>
<ul>
<li>首先实例化 <code>Dep</code> 对象</li>
<li>通过执行 <code>def</code> 函数把自身实例添加到对象 <code>value</code> 的 <code>__obj__</code> 属性上</li>
<li>接着对 <code>value</code> 进行判断，对数组会调用 <code>observeArray</code> 方法，否则对纯对象调用 <code>walk</code> 方法；<code>observeArray</code> 遍历数组会再次调用 <code>observe</code> 方法， <code>walk</code> 方法是遍历对象的 key 调用 <code>defineReactive</code> 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="comment">// 实例化一个发布者 dep 用于收集订阅者 watcher</span></span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="comment">// 如果属性值是 数组，调用 数组 hack 方法变成响应式</span></span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是数组 new Observer(data) 会调用 walk 函数</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through each property and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// walk 函数会对 data 中每个属性调用 defineReactive 函数，并将其变为响应式</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h4><p><strong><code>defineReactive</code> 函数主要就是定义一个响应式对象，给对象添加 getter setter</strong></p>
<p><code>defineReactive</code> 函数首先初始化 <code>Dep</code> 对象实例，接着拿到 <code>obj</code> 的属性描述符，然后对子对象递归调用 <code>observe</code> 方法，保证 <code>obj</code> 所有子属性包括嵌套的对象属性都能变成响应式。因此在访问或修改 <code>obj</code> 的任意属性包括子属性，都能触发 getter 和 setter</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化一个发布者 dep 用于收集订阅者 watcher</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了 getter 和 setter 钩子函数则将其去除</span></span><br><span class="line">  <span class="comment">// 新定义的 getter setter 会将其执行，保证不会将原来的覆盖</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象的子对象递归进行 observe 并返回子节点的 Observer 对象</span></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果对象原本具有 getter 方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集 将 watcher 添加到 dep 中该数据属性对应的订阅者数组</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">// 子对象进行依赖收集，其实是将同一个 watcher 观察者实例放入一个是当前 dep 中 该数据属性对应的订阅者数组，另一个是子元素 dep 中的 该数据属性对应的订阅者数组</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          <span class="comment">// 若是数组则要对每个成员进行依赖收集，若数组成员还是数组，则递归</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">            e = value[i]</span><br><span class="line">            e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 通过 getter 方法获得当前值（如果没有，就是 val），和新值比较，一致则不需要执行下面操作</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        <span class="comment">// 如果对象原本用 setter 方法则执行</span></span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 赋新值</span></span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新的值同样要进行 observe，保证数据响应式</span></span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line">      <span class="comment">// 派发更新 dep 对象通知所有观察者</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p><code>defineReactive</code> 方法将普通对象变成响应式对象，<strong>响应式对象 getter 相关的逻辑就是做依赖收集</strong></p>
<p>下面代码两个关键部分， 一个是 <code>const dep = new Dep()</code> 实例化一个 <code>Dep</code> 实例，另一个是 <code>get</code> 函数中通过 <code>dep.depend()</code> 做依赖收集</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化一个发布者 dep 用于收集订阅者 watcher</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果之前该对象已经预设了 getter 和 setter 钩子函数则将其去除</span></span><br><span class="line">  <span class="comment">// 新定义的 getter setter 会将其执行，保证不会将原来的覆盖</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象的子对象递归进行 observe 并返回子节点的 Observer 对象</span></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果对象原本具有 getter 方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集 将 watcher 添加到 dep 中该数据属性对应的订阅者数组</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">// 子对象进行依赖收集，其实是将同一个 watcher 观察者实例放入一个是当前 dep 中 该数据属性对应的订阅者数组，另一个是子元素 dep 中的 该数据属性对应的订阅者数组</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          <span class="comment">// 若是数组则要对每个成员进行依赖收集，若数组成员还是数组，则递归</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">            e = value[i]</span><br><span class="line">            e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><p><strong><code>Dep</code> 类有一个静态属性 <code>target</code>, 指向当前正被计算的 <code>watcher</code>, 因为同一时间只有一个 <code>watcher</code> 被计算，因此 <code>Dep.target</code> 指向的 <code>watcher</code> 是当前全局唯一的</strong>，自身属性 <code>subs</code> 是 <code>watcher</code> 数组</p>
<p><code>Dep</code> 和 <code>watcher</code> 其实是 观察者 设计模式的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">import</span> type Watcher <span class="keyword">from</span> <span class="string">'./watcher'</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// subs 属性维护 watcher 数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个 观察者 watcher</span></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除一个 观察者 watcher</span></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖收集，当存在 Dep.target 时添加观察者 watcher</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// 调用 watcher 的 addDep，this 为 dep</span></span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有观察者，调用 update()</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stablize the subscriber list first</span></span><br><span class="line">    <span class="comment">// 触发更新，遍历 subs 数组，调用 watcher 的 update 方法</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update() <span class="comment">// 遍历调用 watcher 的 update() ，最终调用 watcher 的 run()，执行 callback</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// this is globally unique because there could be only one</span></span><br><span class="line"><span class="comment">// watcher being evaluated at any time.</span></span><br><span class="line"><span class="comment">// Dep.target 指向当前被计算 watcher （全局唯一 watcher） ，同一时间只有一个 watcher 被计算</span></span><br><span class="line"><span class="comment">// 依赖收集完要将 Dep.target 设为 null，防止之后重复添加依赖</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 watcher 观察者实例设置为 Dep.target,用于依赖收集。同时将该实例放入 target 栈中</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 watcher 观察者实例从 target 栈中取出并设置给 Dep.taget</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Dep.target = targetStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><p>声明组件时使用的 watch，实际调用了 <code>new Watcher(a, callback)</code>, watcher 相当于一个观察者。接下来看一下 watcher 代码，看一下它是怎么和 Observer 关联的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/watcher/js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 解析表达式，进行依赖收集的观察者，会在表达式数据更新时触发回调函数。通常用于 $watch api 和指令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  getter: <span class="built_in">Function</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component, // vm</span><br><span class="line">    expOrFn: string | Function, // 表达式</span><br><span class="line">    cb: Function, // 回调</span><br><span class="line">    options?: Object = &#123;&#125;</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="comment">// _watchers 存放订阅者实例 new Watcher(vm, ....)</span></span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">    <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">    <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">    <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">    <span class="keyword">this</span>.expression = expOrFn.toString()</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn </span><br><span class="line">      <span class="comment">// 初始化渲染 new Watcher(vm, () =&gt; vm._update(vm._render(), hydrating))</span></span><br><span class="line">      <span class="comment">// 此时 this.getter = () =&gt; vm._update(vm._render(), hydrating)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">          <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">          <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new Watcher() 会调用 this.get()（pushTaget(this)），就会将自身 watcher 赋给 Dep.target</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获得 getter 值并重新进行依赖收集</span></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">// 将自身 watcher 观察者实例设置给 Dep.target，用来依赖收集</span></span><br><span class="line">    <span class="comment">// 相当于 Dep.target = this(watcher)</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      <span class="comment">// 递归每个对象或者数组，触发它们的 getter，使得对象或数组的每一个成员都被依赖收集</span></span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将之前的观察者实例从 target 栈中取出并设置给 Dep.target</span></span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        <span class="comment">// 调用 dep 对象添加自身 watcher</span></span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// watcher 更新</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">// 同步则执行 run 方法 直接渲染视图</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异步推送到观察者队列中，下一个 tick 时调用</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 获取观察者的值</span></span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="keyword">this</span>.deps</span><br><span class="line">    <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">    <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">    <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h4><p>Vue 的 mount 过程核心是通过</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;, noop)</span><br><span class="line">hydrating = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>实例化一个渲染 <code>watcher</code> 时，首先进入 <code>wacher</code> 构造函数逻辑，执行 <code>this.get()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">this</span>.getter.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm)</span><br><span class="line">  <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">  <span class="comment">// dependencies for deep watching</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">    traverse(value)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">  <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先执行 <code>pushTarget(this)</code> 实际上是把将 <code>Dep.target</code> 指向的 <code>watcher</code> 先压栈(为了恢复用)，接着将<strong>自身赋值给 <code>Dep.target</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着执行 <code>value = this.getter.call(this.vm, this.vm)</code>, 此时 <code>this.getter</code> 对应的就是 <code>() =&gt; vm._update(vm._render(), hydrating)</code>,<br>实际就是执行 <code>vm._update(vm._render(), hydrating)</code></p>
<p>它首先执行 <code>vm._render()</code>, 内部通过 <code>render</code> 函数生成渲染 vnode，在这个过程上会对 vm 上的数据进行访问，就触发了数据对象的 getter</p>
<p>每个对象值的 getter 都有一个 <code>dep</code>, 在触发 getter 的时候会调用 <code>dep.depend()</code>，也就会执行 <code>Dep.target.addDep(this)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/watcher.js</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dep.target</code> 已经被赋值为 渲染 <code>watcher</code>, 这里主要是做一些逻辑判断（保证同一个数据不会被添加多次）后执行 <code>dep.addSub(this)</code>, 就会执行 <code>this.subs.push(sub)</code>，也就是把当前 <code>watcher</code> 订阅到这个数据持有的 <code>dep</code> 的 <code>subs</code> 中，目的是为后续数据变化时通知到哪些 <code>subs</code> 做准备</p>
<p>在 <code>vm._render()</code> 过程中，会触发所有数据的 getter，实际完成了依赖收集的过程。</p>
<p>回到 <code>get</code> 方法中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">  traverse(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val: any, seen?: Set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">if</span> (!seen) &#123;</span><br><span class="line">    seen = seenObjects</span><br><span class="line">    seen.clear()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">const</span> isO = isObject(val)</span><br><span class="line">  <span class="keyword">if</span> ((isA || isO) &amp;&amp; <span class="built_in">Object</span>.isExtensible(val)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">      <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">      <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        seen.add(depId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">      i = val.length</span><br><span class="line">      <span class="keyword">while</span> (i--) traverse(val[i], seen)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isO) &#123;</span><br><span class="line">      keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">      i = keys.length</span><br><span class="line">      <span class="keyword">while</span> (i--) traverse(val[keys[i]], seen)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是递归访问 <code>value</code>, 触发它所有子项的 <code>getter</code>，接下来执行 <code>popTarget()</code>，也就是 <code>Dep.target = targetStack.pop()</code>。实际上就是把 <code>Dep.target</code> 恢复成上一个状态，因为此时当前 vm 的数据依赖已经收集完成，对应的渲染 <code>Dep.target</code> 也需要改变。最后执行 <code>this.cleanupDeps()</code></p>
<h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><p>在给数据设置响应式，getter 进行依赖收集，目的就是修改数据时可以对相关的依赖派发更新</p>
<h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><p>setter 的核心逻辑有 2 个，一个是 <code>childOb = observe(newVal)</code>，会把新值变为响应式对象，另一个 <code>dep.notify()</code> 通知所有观察者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (newVal === value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="过程分析-1"><a href="#过程分析-1" class="headerlink" title="过程分析"></a>过程分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observerdep.js/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对组件中的响应的数据进行修改会触发 setter 的逻辑，调用 <code>dep.notify()</code> 方法，遍历所有 <code>subs</code>，也就是 <code>watcher</code> 实例数组，然后调用每一个 <code>watcher</code> 的 <code>update</code> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">// 同步则执行 run 方法 直接渲染视图</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异步推送到观察者队列中，下一个 tick 时调用</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里针对 <code>watcher</code> 的不同状态，会执行不同的逻辑，在一般组件数据更新的场景，会走到最后一个 <code>queueWatcher(this)</code> 逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 将一个观察者对象 watcher 推送到观察者队列中，如果队列中已经存在相同的 id 则跳过该观察者，除非是在队列被刷新时推送</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 watcher id</span></span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="comment">// 检验 watcher id，已经存在跳过该观察者，不存在则标记哈希 has 为 true，用于下次检验</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      <span class="comment">// 如果没有 flush 掉，watcher 添加到 队列中</span></span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="comment">// 当 flushing 为 true，会从后往前找，找到第一个等待插入的 watcher id 比当前队列中 watcher id 大的位置，把 watcher 按照 id 插入到队列中，因此 queue 队列的长度发生了变化</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(<span class="built_in">Math</span>.max(i, index) + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// nextTick 后执行 flushSchedulerQueue</span></span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入一个队列的概念，vue 派发更新的时候，并不会每次数据修改都触发 <code>watcher</code> 的回调，而是把这些 <code>watcher</code> 先添加都一个队列里，在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code>。同时 id 重复的 <code>watcher</code> 不会被多次添加到队列中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// nextTick 的回调，在下一个 tick 时 flush 掉队列同时运行 watcher</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  给 queue 队列排序，这样可以保证：</span></span><br><span class="line"><span class="comment">  1.组件更新的顺序是从父组件到子组件，应为父组件总是比子组件先创建</span></span><br><span class="line"><span class="comment">  2.一个组件的 user watcher 比 render watcher 先运行，因为 user watcher 往往比 render watcher 更早创建</span></span><br><span class="line"><span class="comment">  3.如果一个组件在父组件 watcher 运行期间被销毁，它的 watcher 执行将会被跳过</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="comment">// 这里不用 index = queue.length; index &gt; 0; index-- 的方式是因为不要将 length 进行缓存，因为在执行处理现有 watcher 对象期间，更多的 watcher 可能会被 push 进 queue 队列中</span></span><br><span class="line">  <span class="comment">// 队列遍历 执行 watcher run 方法 更新视图</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = queue[index]</span><br><span class="line">    <span class="keyword">const</span> id = watcher.id</span><br><span class="line">    <span class="comment">// 将 has 的标记清除</span></span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 调用 watcher run 方法 更新视图</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      在测试环境中，检测 watch 是否在死循环中</span></span><br><span class="line"><span class="comment">      如</span></span><br><span class="line"><span class="comment">      watch: &#123;</span></span><br><span class="line"><span class="comment">        test() &#123; this.test++ &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      持续执行了 100 次 watch 代表可能存在死循环</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; config._maxUpdateCount) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">'flush'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 状态恢复</span></span><br><span class="line">  resetSchedulerState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flushSchedulerQueue</code> <strong>是下一个 tick 时的回调函数，主要目的是执行 <code>watcher</code> 的 <code>run</code> 方法，用来更新视图</strong></p>
<p>这里主要有个三个核心逻辑：</p>
<ul>
<li>队列排序</li>
</ul>
<p><code>queue.sort((a, b) =&gt; a.id - b.id)</code> 对队列根据 id 从小到达进行排序，主要是保证：</p>
<p>1.组件更新的顺序是从父组件到子组件，应为父组件总是比子组件先创建<br>2.用户自定义的 <code>watcher</code> 比渲染 <code>watcher</code> 先运行，因为 user <code>watcher</code> 往往比渲染 <code>watcher</code> 更早创建<br>3.如果一个组件在父组件 <code>watcher</code> 运行期间被销毁，它的 <code>watcher</code> 执行将会被跳过，所以父组件的 <code>watcher</code> 应该先执行</p>
<ul>
<li>队列遍历</li>
</ul>
<p>对 <code>queue</code> 队列排序后，接着进行遍历，拿到对应 <code>watcher</code>，执行 <code>watcher.run()</code>。这里要注意，在遍历的时候每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 时，用户可能会再次添加新的 <code>watcher</code>，这样会再次执行 <code>queueWatcher</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 watcher id</span></span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="comment">// 检验 watcher id，已经存在跳过该观察者，不存在则标记哈希 has 为 true，用于下次检验</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      <span class="comment">// 如果没有 flush 掉，watcher 添加到 队列中</span></span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="comment">// 当 flushing 为 true，会从后往前找，找到第一个等待插入的 watcher id 比当前队列中 watcher id 大的位置，把 watcher 按照 id 插入到队列中，因此 queue 队列的长度发生了变化</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(<span class="built_in">Math</span>.max(i, index) + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>flushing</code> 为 true，会从后往前找，找到第一个等待插入的 <code>watcher</code> id 比当前队列中 <code>watcher</code> id 大的位置，把 <code>watcher</code> 按照 id 插入到队列中，因此 <code>queue</code> 队列的长度发生了变化</p>
<ul>
<li>状态恢复</li>
</ul>
<p><code>queueWatcher</code> 最后执行 <code>resetSchedulerState()</code>。逻辑就是清空 <code>watcher</code> 队列并把一些变量重置到初始值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/scheduler.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset the scheduler's state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 清空 watcher 队列</span></span><br><span class="line">  queue.length = <span class="number">0</span></span><br><span class="line">  has = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>watcher.run()</code> 方法执行先通过 <code>this.get()</code> 得到它的当前值，然后判断如果满足新旧值不等、新值是对象类型、<code>deep</code> 模式中的任意一个条件，执行 <code>watcher</code> 的回调</p>
<p>这里 <code>watcher</code> 的回调函数执行时候会把第一个和第二个参数传入新值 <code>value</code> 和旧值 <code>oldValue</code>, 因此在组件中添加自定义 <code>watcher</code> 的时候可以在回调函数的参数中拿到新旧值</p>
<p>对于渲染 <code>watcher</code>, 执行 <code>this.get()</code>，会执行 <code>getter</code> 方法，也就是传入的第二个参数 <code>() =&gt; vm._update(vm._render(), hydrating)</code>, 因此修改组件相关的响应式数据时，会触发组件重新渲染，重新执行 <code>patch</code> 过程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/watcher.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="keyword">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="keyword">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">              <span class="string">`Error in watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>,</span><br><span class="line">              <span class="keyword">this</span>.vm</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">            <span class="keyword">if</span> (config.errorHandler) &#123;</span><br><span class="line">              config.errorHandler.call(<span class="literal">null</span>, e, <span class="keyword">this</span>.vm)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><h4 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h4><p><strong>JS 执行是单线程的，它是基于事件循环</strong>。事件循环大致分为以下几个步骤</p>
<ul>
<li><strong>所有同步任务都是在主线程上执行，形成一个执行栈（execution context stack）</strong></li>
<li><strong>主线程之外，还存在一个“任务队列”（task queue）。只要异步任务有了运行结果，会在“任务队列”中放置一个事件</strong></li>
<li><strong>一旦“执行栈”中所有同步任务执行完毕，系统会读取“任务队列”，看有哪些事件。那些对应的异步任务于是结束等待状态，进入执行栈开始执行</strong></li>
<li>主线程不断重复上述三个步骤</li>
</ul>
<p><img src="http://ony85apla.bkt.clouddn.com/18-6-14/25554080.jpg" alt=""></p>
<p><strong>主线程的执行过程就是一个 tick</strong>, 所有的异步结果都是通过任务队列来调度。规范中规定 <strong>异步 task 分为两大类，分别是 macro task（宏任务）和 micro task（微任务），并且每个 macro task（宏任务） 结束后，都要清空所有的 micro task（微任务）</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (macroTask <span class="keyword">of</span> macroTaskQueue) &#123;</span><br><span class="line">  <span class="comment">// 1. 处理当前 macro task 宏任务</span></span><br><span class="line">  handleMacroTask()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 处理全部 micro task 微任务</span></span><br><span class="line">  <span class="keyword">for</span> (microTask <span class="keyword">of</span> microTaskQueue) &#123;</span><br><span class="line">    handleMicroTask(microTask)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浏览器环境中，常见的 macro task（宏任务） 有 <code>setTimout</code> <code>MessageChannel</code> <code>postMessage</code> <code>setImmediate</code>; 常见的 micro task（微任务）有 <code>MutationObserver</code> <code>Promise</code></p>
<h4 id="Vue-中-nextTick"><a href="#Vue-中-nextTick" class="headerlink" title="Vue 中 nextTick"></a>Vue 中 nextTick</h4><p><code>nextTick</code> 的目的就是产生一个回调函数加入 macro task 或 micro task 中，当执行栈执行完后调用该回调函数，起到异步触发（下一个 tick 触发）的目的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/util/env.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defer a task to execute it asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  延迟一个任务使其异步执行，在下一个 tick 时执行，一个立即执行函数，返回一个 function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存放异步执行的回调</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line">  <span class="comment">// 一个标记位，如果已经有 timerFunc 被推送到任务队列中则不需要重复推送</span></span><br><span class="line">  <span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 一个函数指针，指向函数被推送到任务队列中，等到主线程任务执行完，任务队列中的 timerFunc 被调用</span></span><br><span class="line">  <span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个 tick 时的回调</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一个标记位，标记等待状态（即函数已经被推入到任务队列或主线程，已经在等待当前栈执行完毕去执行）</span></span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 执行所有 callback</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">      copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line">  <span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line">  <span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line">  <span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line">  <span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line">  <span class="comment">// Promise is available, we will use it:</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一共有 Promise、MutationObserver 和 setTimeout 三种尝试得到 timerFunc 的方法</span></span><br><span class="line"><span class="comment">    优先使用 Promise，在 Promise 不存在的情况下使用 MutationObserver，这两种方法都会在 micro task(微任务)中执行，会比 setTimout（属于 macro task 宏任务） 更早执行</span></span><br><span class="line"><span class="comment">    如果上述两种方法都不执行的环境会使用 setTimeout，在 macro task 尾部推入这个函数，等待调用执行</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve() <span class="comment">// 返回一个 promise</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      p.then(nextTickHandler)</span><br><span class="line">      <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">      <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">      <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">      <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">      <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">      <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">  )) &#123;</span><br><span class="line">    <span class="comment">// use MutationObserver where native Promise is not available,</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS IE11, iOS7, Android 4.4</span></span><br><span class="line">    <span class="comment">// 新建一个 textNode 的 dom 对象，用 MutationObserver 绑定该 dom 并执行回调函数，在 dom 变化时候回触发回调，该回调会进入主线程（比 macro task 优先执行）</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">    observer.observe(textNode, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">      textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fallback to setTimeout</span></span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="comment">// 使用 setTimeout 将回调推入 macro task 队列尾部</span></span><br><span class="line">    timerFunc = setTimeout</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    推动到队列中下一个 tick 时执行</span></span><br><span class="line"><span class="comment">    cb 回调函数</span></span><br><span class="line"><span class="comment">    ctx 上下文</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> func = ctx</span><br><span class="line">      ? <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; cb.call(ctx) &#125;</span><br><span class="line">      : cb</span><br><span class="line">    <span class="comment">// cb 存到 callbacks 中</span></span><br><span class="line">    callbacks.push(func)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span></span><br><span class="line">      timerFunc(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>之前 <code>watcher.run()</code> 异步会执行 <code>queueWatcher(this)</code>, 最终会执行 <code>nextTick(flushSchedulerQueue)</code>。</p>
<p><code>nextTick</code> 函数是一个立即执行函数，返回 <code>queueNextTick</code> 函数。<code>queueNextTick</code> 方法的逻辑很简单，就是将传入的 <code>cb</code> 放入 <code>callbacks</code> 数组，然后执行 <code>timerFunc</code>(pending 是一个状态标记，用于保证 timerFunc 在下一个 tick 之前只执行一次)</p>
<blockquote>
<p><strong><code>timerFunc</code> 其实是一个异步函数的实现，在该异步函数内部遍历 <code>callbacks</code> 中的 <code>cb</code> 并执行 <code>cb</code>。对于不同的环境实现 <code>timerFunc</code>, 会按照支持 Promise、MutationObserver、setTimeout 的先后顺序（前两者都属于 micro task 微任务，比 属于 macro task 宏任务 的 setTimeout 执行快）来实现封装一个异步方法。<code>timerFunc</code> 作为异步回调最后会加入 micro task 或 macro task 中，在执行栈执行完毕后调用该回调函数，起到了异步触发（下一个 tick）的目的</strong></p>
</blockquote>
<p><code>nextTick(flushSchedulerQueue)</code> 最后不论内部是用 Promise MutationOBserver 还是 setTimeout 封装 <code>timerFunc</code>, 它们都会在下一个 tick 执行 <code>flushSchedulerQueue</code>, 也就是对 <code>callbacks</code> 遍历，执行对应的回调函数</p>
<h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><h3 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h3><p><code>new Vue({})</code> 调用了构造函数中的 <code>this._init()</code>, <code>this._init()</code> 最后调用了 <code>initRender()</code>,  <code>initRender()</code> 最后执行 <code>vm.$mount()</code></p>
<p><code>$mount</code> 方法在多个文件中都有定义，<code>src/entries/web-runtime-with-compiler.js</code>、<code>src/entries/web-runtime.js</code> 等。我们重点分析带有 <code>compiler</code> 版本的 <code>$mount</code> 实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/entries/web-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="comment">// el 不能挂载在 html body 这样的根节点上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="comment">// 如果 vue 实例选项中 render 属性不存在，将 template / el 转化为 render 函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">let</span> isFromDOM = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 如果 vue 实例选项中存在 template 属性</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          isFromDOM = <span class="literal">true</span></span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        isFromDOM = <span class="literal">true</span></span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 如果 vue 实例选项中 template 属性不存在，将 el 的 outerHTMl 作为 模板</span></span><br><span class="line">      isFromDOM = <span class="literal">true</span></span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">// 通过 compileToFunctions 方法将 template （无论 template 属性值 还是 el 的 outerHTML）转为 render 函数</span></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        warn,</span><br><span class="line">        isFromDOM,</span><br><span class="line">        shouldDecodeTags,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        delimiters: options.delimiters</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// 将 render 函数挂载到 vm.$options.render 属性</span></span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码首先缓存原先原型上的 <code>$mount</code> 方法（<code>src/entries/web-runtime.js</code> 中定义），再重新定义该方法</p>
<ul>
<li>首先对 <code>el</code> 做出限制，不能挂载在 <code>body</code>、<code>html</code> 这样的根节点上</li>
<li>核心逻辑是，对于没有定义 <code>render</code> 方法，会将 <code>template</code> 字符串，如果还没有 <code>template</code> 属性，会将 <code>el</code> 的 outerHTML 转为 <code>render</code> 函数</li>
</ul>
<blockquote>
<p><strong>Vue 2.0 中所有 vue 组件的渲染都需要 render 函数，不管是单文件组件 .vue 文件，还是 el 或者 template 属性，最终都会通过 compileToFunctions 方法转为 render 函数</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/entries/web-runtime.js</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; !config._isServer ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 调用 vm._mount</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._mount(el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原先原型上的 <code>$mount</code> 方法，第一个参数是 <code>el</code>, 在浏览器环境下回调用 <code>query</code> 方法转换为 dom 对象，第二个参数和服务端渲染有关，在浏览器环境下不需要传递</p>
<p><code>$mount</code> 方法实际调用 <code>src/core/instance/lifecycle.js</code> 下的 <code>_mount</code> 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/instance/lifecycle.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: Element | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">  <span class="comment">// 初始化渲染 watcher，</span></span><br><span class="line">  vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 调动 vm._render, 通过 render 函数返回 vnode</span></span><br><span class="line">    <span class="comment">// 首次渲染 和 每次数据属性更新会执行该 watcher 中的回调，执行 vm._update() 对 vnode 进行 diff 和 patch</span></span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;, noop)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// root instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$root === vm) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>_mount</code> 方法核心先调用 <code>vm._render</code> 方法先生成 vnode，再实例化一个渲染 <code>watcher</code>，在它的回调函数中将 <code>vm._render</code> 返回的 vnode 传入 <code>vm._update</code> 调用更新 dom</p>
<blockquote>
<p><code>watcher</code> 在这里起到两个作用</p>
<ul>
<li><strong>初始化会执行回调函数</strong></li>
<li><strong>当 vm 实例中监听的数据发生变化时会执行回调函数</strong></li>
</ul>
</blockquote>
<p>函数最后判断为根节点的时候设置 <code>vm._isMounted</code> 为 <code>true</code>, 表示实例已经挂载，同时执行 <code>mounted</code> 钩子函数</p>
<h3 id="编译-render-函数"><a href="#编译-render-函数" class="headerlink" title="编译 render 函数"></a>编译 render 函数</h3><h4 id="render-函数概念"><a href="#render-函数概念" class="headerlink" title="render 函数概念"></a>render 函数概念</h4><p><code>render 函数</code> 是通过编译模板(<code>template</code> 或 <code>el</code> 的 outerHTML)得到，其运行结果是 vnode</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>I am a template!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"message"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No message.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Vue.compile(template)</code> 编译上面的模板会返回一个对象，对象中含有 <code>render</code> 和 <code>staticRenderFns</code> 两个值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的 render 函数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> _c( <span class="comment">// _c 为 createElement 方法(创建元素)</span></span><br><span class="line">      <span class="string">'div'</span>, <span class="comment">// 创建一个 div 元素</span></span><br><span class="line">      &#123;</span><br><span class="line">        attrs:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125; <span class="comment">// div 添加属性 id</span></span><br><span class="line">      &#125;,</span><br><span class="line">      [ <span class="comment">// _m 为 renderStatic 方法（渲染静态节点）</span></span><br><span class="line">        _m(<span class="number">0</span>), <span class="comment">// 这里为静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数</span></span><br><span class="line">        _v(<span class="string">" "</span>), <span class="comment">// _v 为 createTextNode 方法(创建文本 dom) 这里为空的文本节点</span></span><br><span class="line">        (message) <span class="comment">// 三元表达式，判断 message 是否存在</span></span><br><span class="line">          <span class="comment">// 存在就创建 p 元素，元素里有文本，值为 toString(message)</span></span><br><span class="line">          ? _c(<span class="string">'p'</span>,[_v(_s(message))]) <span class="comment">// _s 为 toString 方法（转为字符串）</span></span><br><span class="line">          <span class="comment">// 不存在就创建 p 元素，元素里文本值为 No message.</span></span><br><span class="line">          :_c(<span class="string">'p'</span>,[_v(<span class="string">"No message."</span>)])</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了 <code>render</code> 函数，还有一个 <code>staticRenderFns</code> 数组，这个数组中的函数和 vnode 中 diff 算法优化有关，会在比编译阶段给之后不会发生变化的 vnode 打上 <code>static</code> 为 <code>true</code> 的标签，那些被标记为静态节点的 vnode 会单独生成 <code>staticRenderFns</code> 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//上面 render 函数 中的 _m(0) 会调用这个方法</span></span><br><span class="line">  <span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> _c(</span><br><span class="line">      <span class="string">'header'</span>,</span><br><span class="line">      [</span><br><span class="line">        _c(</span><br><span class="line">          <span class="string">'h1'</span>,</span><br><span class="line">          [</span><br><span class="line">            _v(<span class="string">"I'm a template!"</span>)</span><br><span class="line">          ]</span><br><span class="line">        )</span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="编译-render-函数过程"><a href="#编译-render-函数过程" class="headerlink" title="编译 render 函数过程"></a>编译 render 函数过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/entries/web-runtime-with-compiler.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">  warn,</span><br><span class="line">  isFromDOM,</span><br><span class="line">  shouldDecodeTags,</span><br><span class="line">  shouldDecodeNewlines,</span><br><span class="line">  delimiters: options.delimiters</span><br><span class="line">&#125;, <span class="keyword">this</span>)</span><br><span class="line">options.render = render</span><br><span class="line">options.staticRenderFns = staticRenderFns</span><br></pre></td></tr></table></figure>
<p><code>src/entries/web-runtime-with-compiler.js</code> 中 <code>$mount</code> 方法通过调用  <code>compileToFunctions</code> 方法, 把模板 <code>template</code> 编译生成 <code>render</code> 以及 <code>staticRenderFns</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/platforms/web/compiler/index.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> &#123; compile <span class="keyword">as</span> baseCompile &#125; <span class="keyword">from</span> <span class="string">'compiler/index'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  options = options</span><br><span class="line">    ? extend(extend(&#123;&#125;, baseOptions), options)</span><br><span class="line">    : baseOptions</span><br><span class="line">  <span class="comment">// 合并参数，返回</span></span><br><span class="line">  <span class="keyword">return</span> baseCompile(template, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compileToFunctions</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: CompilerOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  vm?: Component</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledFunctionResult</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _warn = (options &amp;&amp; options.warn) || warn</span><br><span class="line">  <span class="comment">// detect possible CSP restriction</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'return 1'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.toString().match(<span class="regexp">/unsafe-eval|CSP/</span>)) &#123;</span><br><span class="line">        _warn(</span><br><span class="line">          <span class="string">'It seems you are using the standalone build of Vue.js in an '</span> +</span><br><span class="line">          <span class="string">'environment with Content Security Policy that prohibits unsafe-eval. '</span> +</span><br><span class="line">          <span class="string">'The template compiler cannot work in this environment. Consider '</span> +</span><br><span class="line">          <span class="string">'relaxing the policy to allow unsafe-eval or pre-compiling your '</span> +</span><br><span class="line">          <span class="string">'templates into render functions.'</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> key = options &amp;&amp; options.delimiters</span><br><span class="line">    ? <span class="built_in">String</span>(options.delimiters) + template</span><br><span class="line">    : template</span><br><span class="line">  <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="comment">// 传入 template，调用 compile 方法编译</span></span><br><span class="line">  <span class="keyword">const</span> compiled = compile(template, options)</span><br><span class="line">  <span class="comment">// 得到 render 函数的字符串后，通过 new Function 得到真正的渲染函数</span></span><br><span class="line">  res.render = makeFunction(compiled.render)</span><br><span class="line">  <span class="keyword">const</span> l = compiled.staticRenderFns.length</span><br><span class="line">  res.staticRenderFns = <span class="keyword">new</span> <span class="built_in">Array</span>(l)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.render === noop || res.staticRenderFns.some(<span class="function"><span class="params">fn</span> =&gt;</span> fn === noop)) &#123;</span><br><span class="line">      _warn(</span><br><span class="line">        <span class="string">`failed to compile template:\n\n<span class="subst">$&#123;template&#125;</span>\n\n`</span> +</span><br><span class="line">        detectErrors(compiled.ast).join(<span class="string">'\n'</span>) +</span><br><span class="line">        <span class="string">'\n\n'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (cache[key] = res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunction</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将函数字符串生成函数并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(code)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> noop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compileToFunctions</code> 方法接受三个参数：编译模板 <code>template</code>、编译配置 <code>options</code>。核心的编译过程就是 <code>const compiled = compile(template, options)</code></p>
<p><code>compile</code> 函数执行的逻辑是先处理配置参数，真正的编译过程是 <code>return baseCompile(template, options)</code></p>
<p><code>baseCompile</code> 方法在 <code>src/compiler/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/compiler/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  template: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: CompilerOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CompiledResult</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 解析模板字符串生成 AST 树</span></span><br><span class="line">  <span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line">  <span class="comment">// 优化语法树</span></span><br><span class="line">  optimize(ast, options)</span><br><span class="line">  <span class="comment">// 生成代码</span></span><br><span class="line">  <span class="keyword">const</span> code = generate(ast, options)</span><br><span class="line">  <span class="comment">// 输出包含 AST、render 函数字符串、staticRenderFns 字符串的对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ast,</span><br><span class="line">    render: code.render,</span><br><span class="line">    staticRenderFns: code.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>parse</code> 函数（<code>src/compiler/parse/index.js</code> 中定义）主要作用是将模板字符串 <code>template</code> 里的结构(指令、属性、标签等)转为 AST 形式存进 ASTElement 中，最后解析生成 AST</strong>。整个 parse 的过程是利用<strong>正则表达式顺序解析模板</strong>，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。AST 元素节点总共有 3 种类型，type 为 1 表示是普通元素，为 2 表示是表达式，为 3 表示是纯文本。</p>
<p><strong><code>optimize</code> 函数（<code>src/compiler/optimizer.js</code> 中定义）主要功能就是标记静态节点，为后面的 <code>patch</code> 过程对比新旧 vnode 结构做优化。被标记为 static 的节点在后面的 diff 算法被直接忽略，不做详细比较</strong> (vue 是数据驱动，响应式的，但是应用中的数据并不全是响应式，很多数据是首次渲染就永远不会变化，那么这部分数据生成的 dom 也不会变化，可以再 <code>diff</code> <code>patch</code> 过程跳过对比)</p>
<p><strong><code>generate</code> 函数主要功能就是根据 AST 结构拼接生成 <code>render 函数</code> 的字符串</strong></p>
<blockquote>
<p>总结：render 函数编译过程</p>
</blockquote>
<ul>
<li>解析模板字符串（<code>template</code> 、<code>el</code> outerHTML）生成 AST <code>const ast = parse(template.trim(), options)</code></li>
<li>优化语法树  <code>optimize(ast, options)</code></li>
<li>生成代码  <code>const code = generate(ast, options)</code></li>
</ul>
<h2 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h2><p>vue 2.0 引入 虚拟 dom，算法来源于 snabbdom。dom 的操作是十分昂贵的，虚拟 dom 对 dom 做了一层映射，将直接对 dom 的一系列操作，映射到操作虚拟 dom。虚拟 dom 上定义了真实 dom 上的一些关键信息</p>
<h3 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h3><p>首先来看一下 <code>core/vdom/vnode.js</code> 中 vnode 的定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VNodeData 类型定义</span></span><br><span class="line"><span class="keyword">export</span> interface VNodeData &#123;</span><br><span class="line">  key?: string | number;</span><br><span class="line">  slot?: string;</span><br><span class="line">  ref?: string;</span><br><span class="line">  tag?: string;</span><br><span class="line">  staticClass?: string;</span><br><span class="line">  class?: any;</span><br><span class="line">  style?: <span class="built_in">Object</span>[] | <span class="built_in">Object</span>;</span><br><span class="line">  props?: &#123; [key: string]: any &#125;;</span><br><span class="line">  attrs?: &#123; [key: string]: any &#125;;</span><br><span class="line">  domProps?: &#123; [key: string]: any &#125;;</span><br><span class="line">  hook?: &#123; [key: string]: <span class="built_in">Function</span> &#125;;</span><br><span class="line">  on?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">  nativeOn?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">  transition?: <span class="built_in">Object</span>;</span><br><span class="line">  show?: boolean;</span><br><span class="line">  inlineTemplate?: &#123;</span><br><span class="line">    render: <span class="built_in">Function</span>;</span><br><span class="line">    staticRenderFns: <span class="built_in">Function</span>[];</span><br><span class="line">  &#125;;</span><br><span class="line">  directives?: VNodeDirective[];</span><br><span class="line">  keepAlive?: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// core/vdom/vnode.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: Array&lt;VNode&gt; | void,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    ns?: string | void,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 当前节点的标签名</span></span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="comment">// 当前节点对应的对象，包含具体的一些数据，VNodeData 类型</span></span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="comment">// 当前节点的子节点，是一个数组</span></span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="comment">// 当前节点的文本</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">// 当前虚拟节点对应的真实 dom 节点</span></span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="comment">// 当前节点的命名空间</span></span><br><span class="line">    <span class="keyword">this</span>.ns = ns</span><br><span class="line">    <span class="comment">// 当前节点的编译作用域</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="comment">// 节点的 key 属性，被当做节点的标识，用于优化</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="comment">// 组件的 options 选项</span></span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="keyword">this</span>.child = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 当前节点的父节点</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 是否是原生 html 还是普通文本，innerHTML 时候为 true，textContent 为 false</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 是否为静态节点</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 是否作为根节点插入</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 是否为注释节点</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 是否为克隆节点</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>每一个 vnode 都会映射到一个真实 dom 节点，其中有几个比较重要的属性：</p>
<ul>
<li><code>tag</code> vnode 的标签属性</li>
<li><code>data</code> 包含了最终渲染成真实 dom 节点上的 class attribute style 以及绑定的事件等</li>
<li><code>children</code> vnode 的子节点，是一个数组</li>
<li><code>text</code> 文本属性</li>
<li><code>elm</code> vnode 对应的真实 dom 节点</li>
<li><code>key</code> vnode 的标记，有利于优化</li>
</ul>
<p><strong>vnode 简单理解就是使用 js 对象来描述一个 dom 结构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    id: <span class="string">'app'</span>,</span><br><span class="line">    class: 'main'</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    tag: <span class="string">'p'</span>,</span><br><span class="line">    text: <span class="string">'hello'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终渲染成的 dom</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件挂载"><a href="#组件挂载" class="headerlink" title="组件挂载"></a>组件挂载</h3><p><code>Vue.prototype._init</code> 中调用了 <code>initRender(vm)</code> 并最终调用了 <code>vm.$mount(vm.$options.el)</code>, 实质还是调用 <code>lifecycleMixin()</code> 中定义的 <code>Vue.prototype._mount()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/instance/render.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entries/web-runtime.js</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  el = el &amp;&amp; !config._isServer ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._mount(el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// core/instance/lifecyle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    el?: Element | void,</span></span></span><br><span class="line"><span class="function"><span class="params">    hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// vm.$el 为真实的 node</span></span><br><span class="line">    vm.$el = el</span><br><span class="line">    <span class="comment">// 如果 vm 上没有挂载 render 函数</span></span><br><span class="line">    <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">      <span class="comment">// 空节点</span></span><br><span class="line">      vm.$options.render = emptyVNode</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (vm.$options.template) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">            <span class="string">'option is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">            <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 beforeMount 钩子并触发 beforeMount 事件</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">    <span class="comment">// vm._watche 主要是位了更新 dom</span></span><br><span class="line">    vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// Vue.prototype.render()</span></span><br><span class="line">      <span class="comment">// vm._render() 返回一个 VNode</span></span><br><span class="line">      <span class="comment">// 更新 dom</span></span><br><span class="line">      <span class="comment">// vm._render() 调用 render 函数，会返回一个 VNode，在生成 VNode 过程中，会动态计算 getter，同时推入到 dep 中</span></span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;, noop)</span><br><span class="line">    hydrating = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// root instance, call mounted on self</span></span><br><span class="line">    <span class="comment">// mounted is called for child components in its inserted hook</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$root === vm) &#123;</span><br><span class="line">      vm._isMounted = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 调用 mounted 钩子并触发 mounted 事件</span></span><br><span class="line">      callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_mount() 执行过程中 <code>vm._watcher = new Watcher(vm, () =&gt; { vm._update(vm._render(), hydrating) }), noop)</code> 需要重点分析</p>
<p><code>vm._update(vm._render(), hydrating)</code> 被调用时，<code>vm._render()</code> 方法会返回一个新的 vnode （需要了解 compile 阶段代码），传入 <code>vm.update()</code> 方法后，会用这个新的 vnode 和旧的 vnode 进行 diff，最后完成 dom 的给你个新工作</p>
<p><code>vm._watcher = new Watcher(vm, () =&gt; { vm._update(vm._render(), hydrating) }), noop)</code> 会实例化一个 watcher：</p>
<ul>
<li><strong>在 watcher 实例化过程中 <code>this.value = this.lazy ? undefined : this.get()</code> ，会调用 <code>this.get()</code> 方法，<code>Dep.target</code> 会被设为当前这个 watcher</strong></li>
<li><strong>通过 vm._render() 方法生成新的 VNode 并进行 diff 的过程中完成模板当中变量依赖收集工作。也就是 watcher 被添加到在模板中绑定变量的依赖中，一旦响应式数据发生变化，这些响应式数据所维护的 dep 数组就会调用 <code>dep.notify()</code> 方法完成素有依赖遍历执行的工作，这里面就包括视图更新 <code>vm._update(vm._render(), hydrating)</code></strong></li>
</ul>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch()"></a>patch()</h3><p><code>vm._update()</code> 中关键的是 <code>vm.__patche__()</code> 方法，也是虚拟 dom 中最核心的方法，主要是完成 prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点 patch，最后生成新的真实 dom 节点并完成视图的更新工作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.__patch__ = config._isServer ? noop : patch</span><br><span class="line"></span><br><span class="line"><span class="comment">// platforms/web/runtime/patch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">'core/vdom/patch'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>
<p><code>vm.__patch__()</code> 最终是调用 <code>core/vdom/patch.js</code> 中的 createPatchFunction() 方法, 返回 <code>patch()</code> 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vdom/patch.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> elm, parent</span><br><span class="line">    <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!oldVnode) &#123;</span><br><span class="line">      <span class="comment">// empty mount, create new root element</span></span><br><span class="line">      <span class="comment">// oldVnode 不存在，创建一个新的 root 节点</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 标记旧的 VNode 是否有 nodeType</span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// 认为是同一个节点（只是局部更新）就对 oldVnode 和 vnode 进行 diff，并对 oldVnode 打 patch</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 insert 钩子</span></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    <span class="keyword">return</span> vnode.elm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断新旧 vnode 是否只是进行局部更新的同一个节点是通过 <code>sameVnode()</code> 方法， <strong>只有这 2 个 vnode 的基本属性相同才会认为这 2 个 vnode 只是局部更新，才会进行 diff。如果 2 个 vnode 的基本属性不一致会直接跳过 diff 过程，根据 vnode 新建一个真实 dom，删除旧的 dom 节点</strong></p>
<p>如 <code>p</code> 和 <code>div</code>, <code>div.classA</code> 和 <code>div.classB</code> 都会认为是不同的结构而不去 diff </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/instance/vdom/patch.js</span></span><br><span class="line"><span class="comment">// 判断两个 vnode 的 key tag isComment 相同，data 存在</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">vnode1, vnode2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    vnode1.key === vnode2.key &amp;&amp;</span><br><span class="line">    vnode1.tag === vnode2.tag &amp;&amp;</span><br><span class="line">    vnode1.isComment === vnode2.isComment &amp;&amp;</span><br><span class="line">    !vnode1.data === !vnode2.data</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>patch 过程总结如下：</p>
<ul>
<li>如果 oldVnode 不存在，<code>createEle(vnode)</code> 为 vnode 直接创建真实 dom</li>
<li>否则利用 <code>sameVnode()</code> 判断新旧 vnode 是否是同一个节点, <strong>不是同一个节点（不是局部更新，没必要进一步 diff），vnode 直接替换 oldVnode</strong></li>
<li>否则新旧 vnode 值得比较，调用 <code>patchVnode()</code></li>
</ul>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/vdom/patch.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> hasData = isDef(i = vnode.data)</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">    <span class="comment">// 如果 vnode 没有文本节点</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="comment">// 如果 oldVnode 和 vnode 的 children 属性都存在</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// updateCihldren, 对子节点进行 diff</span></span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">        <span class="comment">// 如果 oldVnode 的 text 存在，先清空 text 内容</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">        <span class="comment">// 然后将 vnode 的 children 添加进去</span></span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        <span class="comment">// 删除 elm 下的 oldChildren</span></span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        <span class="comment">// oldVnode 有子节点，而 vnode 没有，就清空这个节点</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="comment">// 如果新旧 vnode 文本属性不同，直接更新真实 dom 节点的文本元素</span></span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>patchVnode 中 diff 过程有几种情况，oldCh 为 oldVnode 的子节点， ch 为 vnode 的子节点：</p>
<ul>
<li>首先进行文本节点判断，如果 <code>oldVnode.text !== vnode.text</code>, 直接进行文本节点替换</li>
<li>在 vnode 没有文本节点的情况下，进入子节点 diff</li>
<li>当 oldCh 和 ch 都存在并且不相同的情况下，调用 <code>updateChildren()</code> 对子节点进行 diff</li>
<li>如果 oldCh 不存在，ch 存在，先清空 oldVnode 的文本节点，同时调用 <code>addVnodes()</code> 将 ch 添加到 elm 的真实 dom 节点中</li>
<li>如果 oldCh 存在，ch 不存在，则删除 elm 真实节点下 oldCh 子节点</li>
<li>如果 oldVnode 有文本节点，而 vnode 没有，就清空这个文本节点</li>
</ul>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren()"></a>updateChildren()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为 oldCh 和 newCh 分别建立索引，作为之后遍历的依据</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, before</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transitions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直到 oldCh 或 newCh 被遍历完跳出循环</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      <span class="comment">// 插入到老的开始节点前面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果上述条件都不满足，则开始比较 key 值，首先建立 key 和 index 索引的对应关系</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 如果 idxInOld 不存在</span></span><br><span class="line">      <span class="comment">// 1. newStartVnode 上存在这个 key，但是 oldKeyToIdx 中不存在</span></span><br><span class="line">      <span class="comment">// 2. newStartVnode 上没有设置 key 属性</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">// 创建新的 dom 节点</span></span><br><span class="line">        <span class="comment">// 插入到 oldStartVnode.elm 前面</span></span><br><span class="line">        <span class="comment">// 参见 creatElm() 方法</span></span><br><span class="line">        nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !elmToMove) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'It seems there are duplicate keys that is causing an update error. '</span> +</span><br><span class="line">            <span class="string">'Make sure each v-for item has a unique key.'</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (elmToMove.tag !== newStartVnode.tag) &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">// 创建新的 dom 节点</span></span><br><span class="line">          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          <span class="comment">// 移动 node 节点</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果最后遍历的 oldStartIdx 大于 oldEndIdx</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123; <span class="comment">// 如果是 oldVnode 先被遍历完</span></span><br><span class="line">    before = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    <span class="comment">// 添加 newVnode 中剩余节点到 parentElm 中</span></span><br><span class="line">    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123; <span class="comment">// 如果是 newVnode 新被遍历完，则删除 oldVnode 中所有的节点</span></span><br><span class="line">    <span class="comment">// 删除剩余节点</span></span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/vue/" rel="tag"># vue</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/12/vue 2.0 生命周期/" rel="next" title="vue 2.0 生命周期">
                <i class="fa fa-chevron-left"></i> vue 2.0 生命周期
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars0.githubusercontent.com/u/8380737?s=460&v=4"
                alt="jhgrrewq" />
            
              <p class="site-author-name" itemprop="name">jhgrrewq</p>
              <p class="site-description motion-element" itemprop="description">爱好电影，更爱女神阿佳妮；爱网球，更爱罗杰费德勒。网易云音乐深度用户</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">96</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jhgrrewq" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#代码结构"><span class="nav-number">1.</span> <span class="nav-text">代码结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-构造函数"><span class="nav-number">2.</span> <span class="nav-text">Vue 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initMixin"><span class="nav-number">2.1.</span> <span class="nav-text">initMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stateMixin"><span class="nav-number">2.2.</span> <span class="nav-text">stateMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eventsMixin"><span class="nav-number">2.3.</span> <span class="nav-text">eventsMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lifecycleMixin"><span class="nav-number">2.4.</span> <span class="nav-text">lifecycleMixin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#renderMixin"><span class="nav-number">2.5.</span> <span class="nav-text">renderMixin()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-vue-实例"><span class="nav-number">3.</span> <span class="nav-text">创建 vue 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initLifecycle"><span class="nav-number">3.1.</span> <span class="nav-text">initLifecycle()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initEvents"><span class="nav-number">3.2.</span> <span class="nav-text">initEvents()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initRender"><span class="nav-number">3.3.</span> <span class="nav-text">initRender()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#initState"><span class="nav-number">3.4.</span> <span class="nav-text">initState()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应式原理"><span class="nav-number">4.</span> <span class="nav-text">响应式原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#响应式对象"><span class="nav-number">4.1.</span> <span class="nav-text">响应式对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#initData"><span class="nav-number">4.1.1.</span> <span class="nav-text">initData()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observer-类"><span class="nav-number">4.1.2.</span> <span class="nav-text">Observer 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defineReactive"><span class="nav-number">4.1.3.</span> <span class="nav-text">defineReactive</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖收集"><span class="nav-number">4.2.</span> <span class="nav-text">依赖收集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getter"><span class="nav-number">4.2.1.</span> <span class="nav-text">getter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dep"><span class="nav-number">4.2.2.</span> <span class="nav-text">Dep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watcher"><span class="nav-number">4.2.3.</span> <span class="nav-text">watcher</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过程分析"><span class="nav-number">4.2.4.</span> <span class="nav-text">过程分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派发更新"><span class="nav-number">4.3.</span> <span class="nav-text">派发更新</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setter"><span class="nav-number">4.3.1.</span> <span class="nav-text">setter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过程分析-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">过程分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nextTick"><span class="nav-number">4.4.</span> <span class="nav-text">nextTick</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JS-运行机制"><span class="nav-number">4.4.1.</span> <span class="nav-text">JS 运行机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue-中-nextTick"><span class="nav-number">4.4.2.</span> <span class="nav-text">Vue 中 nextTick</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板编译"><span class="nav-number">5.</span> <span class="nav-text">模板编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mount"><span class="nav-number">5.1.</span> <span class="nav-text">$mount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译-render-函数"><span class="nav-number">5.2.</span> <span class="nav-text">编译 render 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#render-函数概念"><span class="nav-number">5.2.1.</span> <span class="nav-text">render 函数概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译-render-函数过程"><span class="nav-number">5.2.2.</span> <span class="nav-text">编译 render 函数过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟-dom"><span class="nav-number">6.</span> <span class="nav-text">虚拟 dom</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vnode"><span class="nav-number">6.1.</span> <span class="nav-text">vnode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件挂载"><span class="nav-number">6.2.</span> <span class="nav-text">组件挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#patch"><span class="nav-number">6.3.</span> <span class="nav-text">patch()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#patchVnode"><span class="nav-number">6.4.</span> <span class="nav-text">patchVnode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#updateChildren"><span class="nav-number">6.5.</span> <span class="nav-text">updateChildren()</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jhgrrewq</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  


</body>
</html>
