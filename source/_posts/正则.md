---
title: 正则
tag: 
	- 正则
---

<!-- markdownlint-disable MD010 -->

> 正则表达式：单个字符串来描述匹配一系列符合某个句法规则的字符串（即按某个**规则**匹配符合条件的字符串）
> 使用正则表达式图形化工具：http://regexper.com

<!-- more -->
## regexp 对象

- **字面量生成** /pattens/attr

```js
// 匹配 is 单词边界
var reg = /\bis\b/g
'this is a is'.replace(reg, 'IS') // 'this IS a IS'
```

- **构造函数生成** new RegExp(pattens, attr) **注意转义**

```js
var reg = new RegExp('\\bis\\b', 'g')
```

## 匹配位置

- **^ 匹配开始位置**

```js
// /^http/ 匹配 http 开头
var reg = /^http/
reg.test('http:') // true
reg.test('hhttp:')  // false
```

- **$ 匹配结束位置**

```js
// /http$/ 匹配 http 结尾
var reg = /http$/
reg.test('hhttp') // true
reg.test('hhttp:')  // false
```

- **\b 表示单词边界**
- **\B 表示非 单词边界**

```js
// /\bis\b/ 匹配 is 单词
var reg = /\bis\b/
reg.test('this') // false
reg.test('this is')  // true
```

## 元字符（具有特殊意义的字符，匹配单个字符）

正则表达式一般有两种字符，一种是元字符，一种是原义字符。一般情况下正则表达式一个字符对应字符串的一个字符

**. * + ? $ ^ | \ () {} []**

- **^ $ \b**
- **\d 等同 [0-9],表示匹配任意一个数字**
- **\D 等同 [^0-9],表示匹配任意一个非数字字符**
- **\w 等同 [a-zA-Z_0-9],表示匹配任意一个单词字符(字母、数字下划线)**
- **\W 等同 [^a-zA-Z_0-9],表示匹配任意一个非单词字符**
- **\s 等同 [\t\n\x0B\f\r],表示匹配任意一个空白符**
- **\S 等同 [^\t\n\x0B\f\r],表示匹配任意一个非空白符**
- [\u4e00-\u9fa5], 表示匹配任意一个 unicode 字符

还有一些特殊字符
- \t 水平制表符
- \v 垂直制表符
- \n 换行符
- \r 回车符
- \0 空字符
- \f 换页符
- \cX 与 X 对应的控制字符（Ctrl + x）

## 字符类（匹配一类字符中的一个 /[]/）

- **. 匹配除了回车符和换行符以外的任意一个字符，等价 [^\r\n]**

```js
// . 匹配除了换行符以外的的任意一个字符
var reg = /./
reg.test(' ') // true
reg.test('1') // true
```

- **[] 匹配中括号中的任意一类字符中的一个字符**
- **[^] 匹配非 取反**
- **[-] 匹配一个范围的任意一个字符**

```js
/[a-z]/ 匹配任意一个小写字母 等同[0123456789]
/[A-Z]/ 匹配任意一个大写字母
/[abc]/ 匹配a或b或c
/[0-9]/ 匹配任意一个数字
/[a-zA-Z0-9]/ 匹配任意一个单词字符
/[^0-9]/ ^ 这里表示“非”，匹配一个非数字字符
```

```js
// 全局匹配 a b c 中的一个
'a1b2c3'.replace(/[abc]/g, 'X') // 'X1X2X3'
// 全局匹配 非a 或 非b 或 非c
'a1b2c3'.replace(/[^abc]/g, 'X') // 'aXbXcX'

// 全局匹配 数字
'2017-01-02'.replace(/[0-9]/g, 'X') // 'XXXX-XX-XX'
// 如果想把 [] 中的 - 也匹配，只需要在范围后加 - 
'2017-01-02'.replace(/[0-9-]/g, 'X') // 'XXXXXXXXXX'
```

## 量词（出现次数）

- *** 0次或多次，相当于{0,}，任意次**
- **+ 1次或多次，相当于{1,}，至少出现一次**
- **? 0次或1次，相当于{0,1},最多出现一次**

- **{m} 匹配 m 次**
- **{m, n} 匹配 m-n 次**
- **{m,} 至少匹配 m 次**

**注意：上述匹配是尽可能多匹配（贪婪匹配），重复字符后面跟一个 ？为尽可能少匹配（非贪婪匹配）**

```js
var reg = /\d+/
'123abc'.replace(reg, function(str) {
	console.log(str) // 123
})

var reg = /\d+?/
'123abc'.replace(reg, function(str) {
	console.log(str) // 1
})
```

## 分组（多选）

- **（）进行分组，可以使量词作用于所选内容**
- **| 或**

```js
// 匹配 jpg 或 png 文件
var reg = /\.(jpg|png)/
reg.test('test.jpg') // true
reg.test('test.png') // true
reg.test('test.svg') // false

//（）使量词作用于所选内容
var reg = /([a-z]\d){3}/g // 匹配字符数字连续出现三次
'a1b2c3d4'.replace(reg, 'x') // xxxd4
var reg = /[a-z]\d{3}/g // 只能匹配数字连续出现三次
'a1b2c3d4'.replace(reg, 'x') // a1b2c3d4 没有匹配上
```

- **反向引用，使用 $1 - $n 来捕获分组的内容**

```js
// 使用 $1, $2,...,$n 来捕获分组的内容
'2016-01-02'.replace(/(\d{4})-(\d{2})-(\d{2})/g, '$1$2$3') // '20160102'
```

- **忽略分组，不希望捕获某些分析，只需要在分组内加上 ？：**

```js
// 忽略分组，在该分组前加上 ？：
'2016-01-02'.replace(/(?:\d{4})-(\d{2})-(\d{2})/g, '$1$2') // '0102'
```

## 转义

- **对于特殊字符，字面量形式仅仅使用字符串形式，和构造函数形式中正则字符串需要使用特殊字符，需要转义**

```js
// 匹配 2 的 8 次方
var reg = /2\^8/    // 字面量时特殊字符仅正常使用，需要转义
reg.test('2^8 + 1') // true

// 匹配一个数字
var reg = new RegExp('\\d') // 构造函数使用特殊字符需要转义
reg.test('123') // true
var reg = new RegExp('\d')
reg.test('123') // false
```

## 正则表达式修饰符

- **i 忽略全局大小写，默认是 false（大小写敏感）**
- **g 全局匹配，即找到所有的匹配，而不是找到第一个就停止，默认是 false（默认非全局）**
- **m 多行匹配，^ 匹配一行开始，$ 匹配一行结束，默认是 false（非多行）**

```js
// i 忽略大小写，默认是大小写敏感
'He is a boy, is he?'.replace(/\bhe\b/, '0') // 'He is a boy, is 0?'
'He is a boy, is he?'.replace(/\bhe\b/i, '0') // '0 is a boy, is he?'

// g 全局匹配
'He is a boy, is he?'.replace(/\bis\b/, '0') // 'He 0 a boy, is he?'
'He is a boy, is he?'.replace(/\bis\b/g, '0') // 'He 0 a boy, 0 he?'
```

## 前瞻

**前瞻就是在正则表达式匹配规则的时候，向前检查是否符合断言（正则表达式一般文本头部向尾部匹配，文本尾部方向为前）**（也就是不仅满足匹配还要检查是否满足断言）

- **exp(?=assert)** 符合特定断言为正向前瞻
- **exp(?!assert)** 不符合特定断言为负向前瞻

```js
// 全局匹配一个单词字符，同时满足断言 紧跟一个数字
'a2*34vv'.replace(/\w(?=\d)/g, 'x') // 'x2*x4vv'
// 全局匹配一个单词字符，同时满足断言 不紧跟一个数字
'a2*34vv'.replace(/\w(?!\d)/g, 'x') // 'ax*3xxv'
```

## 正则对象属性 (只读)

- **global** 是否全文搜索， 默认是 false
- **ignoreCase** 是否大小写敏感，默认是 false
- **multiline** 多行搜索，默认是 false
- **lastIndex 当前匹配内容的最后一个字符的下一个字符位置（下次匹配开始位置）**
- **source** 正则表达式的文本字符串

```js
var reg1 = /\w/
var reg2 = /\w/gim

reg1.global // false
reg1.ignoreCase // false
reg1.multiline // false
reg1.source // '\w'
reg2.global // true
reg2.ignoreCase // true
reg2.multiline // true
reg2.source // '\w'
reg1.global = true
reg1.global // false 只读
```

## 正则表达式对象方法

**RegExp.prototype.test(str)** 

- 测试字符串参数中是否存在匹配正则表达式模式的字符串，存在返回 true，否则返回 false
- **test 每次匹配不是从头匹配，而是根据 lastIndex 的位置匹配，超过再重置为 0 从头匹配**
- **使用 test 方法，正则表达式没必要加 g 标识进行全局搜索**

```js
// test 每次匹配不是从头匹配，而是根据 lastIndex 的位置匹配，超过再重置为 0 从头匹配
var reg = /\w/g

while(reg.test('ab')) {
	console.log(reg.lastIndex) // 1 // 2
	// lastIndex 是指当前匹配的最后一个字符的下一个字符的位置
	// 这里每个字符都是匹配而且都只有一个字符，第一次匹配的 lastIndex 是 1，第二次 lastIndex 为 2
}

reg.test('ab') // true
reg.test('ab') // true
reg.test('ab') // false
reg.test('ab') // true
```

**RegExp.prototype.exec(str)**

- 没有匹配，返回 null，有匹配返回一个数组，**数组中还会返回两个元素，index 是匹配文本的第一个字符位置， input 则是被检索的字符串**
- 非全局匹配，lastIndex 无效，**数组第一个元素是与正则表达式匹配的文本，第二个元素是与第一个子表达式（第一个分组）匹配的文本（如果有的话），第三个元素是与第二子表达式匹配的文本（第二个分组）（如果有的话），以此类推**

```js
var reg1 = /\d(\w)(\w)\d/
var reg2 = /\d(\w)(\w)\d/g
var ts = '$1aa2b3cc4d5e'

var ret = reg1.exec(ts)

console.log(reg1.lastIndex + '\t' + ret + '\t' + ret.index + '\t' + ret.input) // 0   1aa2,a,a   1   $1aa2b3cc4d5e
// 非全局匹配 正则的 lastIndex 无效，返回数组第一个元素是匹配文本，第二个元素是第一个分组捕获的文本，第三个元素是第二个分组捕获的文本，数组的 index 为匹配文本的第一个字符位置，数组的 input 为被检索的字符串

while(ret = reg2.exec(ts)) {
	console.log(reg2.lastIndex + '\t' + ret + '\t' + ret.index + '\t' + ret.input)
	// 5   1aa2,a,a   1   $1aa2b3cc4d5e
	// 10   3cc4,c,c   1   $1aa2b3cc4d5e
	// 全局匹配，正则的 lastIndex 生效，为当前匹配文本的最后一个字符的下一个字符位置
}
```

## 字符串方法

**String.prototype.search(reg)**

- 检索字符串中与正则表达式匹配的子字符串，**返回第一个匹配的子字符串的位置，否则返回 -1**
- **忽略全局匹配，总是从字符串的开始进行检索**

```js
'a1b2c3'.search('1') // 1
'a1b2c3'.search('10') // -1
'a1b2c3'.search(/1/) // 1
'a1b2c3'.search(/1/g) // 1 忽略全局
```

**String.prototype.match(reg)**

- 非全局匹配，没有匹配返回 null，有匹配返回一个数组，**数组第一个元素是与正则表达式匹配的文本，第二个元素是与第一个子表达式（第一个分组）匹配的文本（如果有的话），第三个元素是与第二子表达式匹配的文本（第二个分组）（如果有的话），以此类推; 数组中还会返回两个元素，index 是匹配文本的第一个字符位置，input 则是被检索的字符串** 等同于 正则的 exec 方法的非全局匹配

- 全局匹配，没有匹配则返回 null，有匹配则返回一个数组，**数组元素是与正则表达式相匹配的匹配的文本，没有分组的元素，数组没有index属性和input属性的元素**

```js
var reg1 = /\d(\w)(\w)\d/
var reg2 = /\d(\w)(\w)\d/g
var ts = '$1aa2b3cc4d5e'

var ret = ts.match(reg1)

console.log(ret + '\t' + ret.index + '\t' + ret.input) // 1aa2,a,a   1   $1aa2b3cc4d5e
// 非全局匹配 (等同 正则的 exec 方法的非全局匹配) 返回数组第一个元素是匹配文本，第二个元素是第一个分组捕获的文本，第三个元素是第二个分组捕获的文本，数组的 index 为匹配文本的第一个字符位置，数组的 input 为被检索的字符串

ret = ts.match(reg2)
console.log(ret + '\t' + ret.index + '\t' + ret.input)
// 1aa2,3cc4   undefined   undefined
// 全部匹配，数组中返回所有匹配的文本，但是没有分组的内容，而且也没有 index 和 input 元素
```

**String.prototype.split(reg)**

- 根据特定字符或者正则将字符串分割成为数组

```js
'a,b,c'.split(',') // ['a', 'b', 'c']
'a,b,c'.split(/,/) // ['a', 'b', 'c']
'a1b2c'.split(/\d/) // ['a', 'b', 'c']
```

**String.prototype.replace**

- 对字符串中符合正则的匹配串用 **其他字符串 或者 替换函数的返回值** 进行替换，最终返回替换后的字符串
- String.prototype.replace(str, replaceStr)
- String.prototype.replace(reg, replaceStr)
- String.prototype.replace(reg, function)

**function 在每次匹配替换时调用，有四类参数，并用函数返回值进行替换**
- **匹配到的字符串**
- **正则表达式的分组内容，可以有多个参数，没有分组就没有该参数（）**
- **匹配项在字符串中的 index**
- **原字符串**

```js
'a1b2c3'.replace('1', 2) // a2b2c3
'a1b2c3'.replace(/\d/g, 2) // a2b2c2

'a1b2c3'.replace(/\d/g, function(match, index, orgin){
	console.log(match, index, orgin)
	// 1 1 a1b2c3
	// 2 3 a1b2c3
	// 3 5 a1b2c3
	return parseInt(match) + 1
}) // a2b3c4

'a1b2c3'.replace(/(\d)(\w)/g, function(match, group1, group2, index, orgin){
	console.log(match, group1, group2, index, orgin)
	// 1b 1 b 1 a1b2c3
    // 2c 2 c 3 a1b2c3
	return group1
}) // a123
```

## 示例

### 邮箱正则匹配

