---
title: 观察者模式 发布-订阅模式
tag: 
	- 观察者模式 发布-订阅模式
	- 设计模式
---

## 概念

> **定义对象之间一对多的依赖关系，当一个对象的状态改变时，所有依赖的对象都会得到通知**

### 观察者模式

- 观察者模式中，观察者和目标是互相知道对方存在，当事件触发，目标直接调用观察者的方法

### 发布-订阅模式

```flow
st=>start: 发布者
e=>end: 订阅者
op=>operation: 调度中心

st(publish event)->op(fire event)->e
e(subscribe)->op
```

- 发布订阅模式中，**通过第三方进行通信**，发布者和订阅者彼此不知道对方存在，方便解耦
- 订阅者将订阅的事件注册到第三方，当事件触发时，发布者将事件发布到第三方，由第三方统一调度订阅者注册到第三方的处理代码

<!-- more -->

## Node.js eventEmitter 观察者模式实现

### 思路

- 指定一个目标

- 为目标添加一个缓存列表，列表中存放观察者

- 当事件触发时目标会遍历缓存列表，依次触发观察者的方法

### 实现

```javascript
function EventEmitter () {
    // 缓存事件/回调键值对
    this._events = this._events || {}
    // 设立监听上线
    this._maxListeners = this._maxListeners || 10
}

EventEmitter.prototype.emit = function() {
    let key = Array.prototype.shift.call(arguments); // 取出参数中的事件类型
    let fns = this._events[key]; // 取出对应事件类型的回调函数数组
    if(!fns || fns.length === 0){  // 如果没有绑定对应信息
        return false
    }
    for(let i = 0; i < fns.length; i++){
        fns[i].apply(this, arguments); // 此时arguments为 emit 调用时带上的参数
    }
}

EventEmitter.prototype.addListener = function(key, fn) {
    if(!this._events[key]){
        this._events[key] = [];
    }
    if (this._events[key].length > this._maxListeners) {
        console.log(`已经超过当前事件的监听上限制，不能超过 ${this._maxListeners}`)
    }
    this._events[key].push(fn); // 观察者添加进缓存列表
}

EventEmitter.prototype.removeListener = function(key, fn) {
    let fns = this._events[key];

    if(!fns){   // 如果key对应的事件类型没有被订阅则返回
        return false
    }
    if(!fn){    // 如果没有传入特定的回调函数，则表示要取消key对应消息类型的所有回调
        fns && (fns.length = 0)
    }else{
        for(let i = fns.length-1; i > 0 ; i--){
            if(fns[i] === fn){
                fns.splice(i,1) // 删除对应的回调函数
            }
        }
    }
}

EventEmitter.prototype.on = function(...arg) {
    this.addListener(...arg)
}

EventEmitter.prototype.once = function(key, fn) {
    let fns = this._events[key]

    let onceFn = function () {
        this.removeListener(key, onceFn)
        fn.apply(this, arguments)
    }

    !fns ? this._events[key] = [onceFn] : this._events[key].push(onceFn)
}

EventEmitter.prototype.removeAllListener = function() {
    this._events = {}
}

let emitter = new EventEmitter()
// 监听同一个事件名
emitter.addListener('arson', man => {
    console.log(`expel ${man}`)
});
emitter.addListener('arson', man => {
    console.log(`save ${man}`)
});

let fn = man => {
    console.log(`kill ${man}`)
}

emitter.on('arson', fn);

emitter.once('arson', () => {
    console.log('once')
});

// 触发事件
emitter.emit('arson', 'low-end')

emitter.removeListener('arson', fn)

emitter.emit('arson', 'low-end')
```

## 发布-订阅模式实现

**利用 立即执行函数 从外部参入发布者，赋值为第三方对象**，函数内部也是观察者机制，维护事件回调键值对

```js
var pubsub = {};
(function(myObject) {
    // Storage for _events that can be broadcast
    // or listened to
    var _events = {}
    // An key identifier
    var subUid = -1
    // Publish or broadcast events of interest
    // with a specific key name and arguments
    // such as the data to pass along
    myObject.publish = function( key, args ) {
        if ( !_events[key] ) {
            return false
        }
        var subscribers = _events[key],
        len = subscribers ? subscribers.length : 0
        while (len--) {
            subscribers[len].func( key, args );
        }
        return this;
    };
    // Subscribe to events of interest
    // with a specific key name and a
    // callback function, to be executed
    // when the key/event is observed
    myObject.subscribe = function( key, func ) {
        if (!_events[key]) {
            _events[key] = [];
        }
        var token = ( ++subUid ).toString();
        _events[key].push({
            token: token,
            func: func
        });
        return token;
    };
    // Unsubscribe from a specific
    // key, based on a tokenized reference
    // to the subscription
    myObject.unsubscribe = function( token ) {
        for ( var m in _events ) {
            if ( _events[m] ) {
                for ( var i = 0, j = _events[m].length; i < j; i++ ) {
                    if ( _events[m][i].token === token ) {
                        _events[m].splice( i, 1 );
                        return token;
                    }
                }
            }
        }
        return this;
    };
}( pubsub ));
```

## Vue 中 $emit $on $once $off 实现

同样的观察者模式 `vm._events` 维护事件回调键值对

`2.2.0` 版本后，传入第一个事件参数如果是字符串，则表示单个事件，如果是数组，则可为多个事件一次性绑定或解绑回调

- `$on` 将观察者添加到对应的事件队列中

- `$once` 将观察者重新封装为一个方法，先对对应事件解绑，在调用，将重新封装的方法注册到对应事件

- `$off` 根据参数不同，可以一次性解绑全部回调方法，解绑对应事件的全部回调，解绑对应事件的对应回调

- `$emit` 取出事件对应的回调数组，依次遍历调用

```js
// src/core/instance/event.js
Vue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {
    const vm: Component = this
    if (Array.isArray(event)) {
        // 数组的话可以一次性绑定多个事件对应的回调
        for (let i = 0, l = event.length; i < l; i++) {
            this.$on(event[i], fn)
        }
    } else {
        // 将观察者添加到对应事件队列中
        (vm._events[event] || (vm._events[event] = [])).push(fn)
        // ...
    }
    return vm
}

Vue.prototype.$once = function (event: string, fn: Function): Component {
    const vm: Component = this
    function on () {
        // 先解绑
        vm.$off(event, on)
        // 再调用原先的回调
        fn.apply(vm, arguments)
    }
    // fn 属性为原先的方法
    on.fn = fn
    vm.$on(event, on)
    return vm
  }

Vue.prototype.$off = function (event?: string | Array<string>, fn?: Function): Component {
    const vm: Component = this
    // all 删除全部
    if (!arguments.length) {
        vm._events = Object.create(null)
        return vm
    }
    // array of events
    // 方便操作，可以一次性解绑多个事件对应的回调
    if (Array.isArray(event)) {
        for (let i = 0, l = event.length; i < l; i++) {
            this.$off(event[i], fn)
        }
        return vm
    }
    // specific event 删除具体事件
    const cbs = vm._events[event]
    if (!cbs) {
        return vm
    }
    if (!fn) {
        vm._events[event] = null
        return vm
    }
    if (fn) {
      // specific handler
        let cb
        let i = cbs.length
        while (i--) {
            cb = cbs[i]
            if (cb === fn || cb.fn === fn) {
            cbs.splice(i, 1)
            break
            }
        }
    }
    return vm
  }

Vue.prototype.$emit = function (event: string): Component {
    const vm: Component = this
    // ...
    let cbs = vm._events[event]
    if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs
        const args = toArray(arguments, 1)
        for (let i = 0, l = cbs.length; i < l; i++) {
            try {
            cbs[i].apply(vm, args)
            } catch (e) {
            handleError(e, vm, `event handler for "${event}"`)
            }
        }
    }
    return vm
}
```
